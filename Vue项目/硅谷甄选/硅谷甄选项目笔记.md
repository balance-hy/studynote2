#                    硅谷甄选运营平台

此次教学课程为硅谷甄选运营平台项目,包含运营平台项目模板从0到1开发，以及数据大屏幕、权限等业务。

此次教学课程涉及到技术栈包含***:vue3+TypeScript+vue-router+pinia+element-plus+axios+echarts***等技术栈。

## 二、搭建后台管理系统模板

### 2.1项目初始化

今天来带大家从0开始搭建一个vue3版本的后台管理系统。一个项目要有统一的规范，需要使用eslint+stylelint+prettier来对我们的代码质量做检测和修复，需要使用husky来做commit拦截，需要使用commitlint来统一提交规范，需要使用preinstall来统一包管理工具。

下面我们就用这一套规范来初始化我们的项目，集成一个规范的模版。

#### 2.1.1环境准备

- node v16.14.2 
- pnpm 8.0.0

#### 2.1.2初始化项目

本项目使用vite进行构建，vite官方中文文档参考：[cn.vitejs.dev/guide/](https://cn.vitejs.dev/guide/)

**pnpm:performant npm ，意味“高性能的 npm”。[pnpm](https://so.csdn.net/so/search?q=pnpm&spm=1001.2101.3001.7020)由npm/yarn衍生而来，解决了npm/yarn内部潜在的bug，极大的优化了性能，扩展了使用场景。被誉为“最先进的包管理工具”**

pnpm安装指令

```
npm i -g pnpm
```

项目初始化命令:

```
pnpm create vite
```

进入到项目根目录pnpm install安装全部依赖.安装完依赖运行程序:pnpm run dev

运行完毕项目跑在http://127.0.0.1:5173/,可以访问你得项目啦

### 2.2项目配置

#### 一、eslint配置

**eslint中文官网:http://eslint.cn/**

ESLint最初是由[Nicholas C. Zakas](http://nczonline.net/) 于2013年6月创建的开源项目。它的目标是提供一个插件化的**javascript代码检测工具**

首先安装eslint

```
pnpm i eslint -D
```

生成配置文件:.eslint.cjs

```
npx eslint --init
```

**.eslint.cjs配置文件**

```
module.exports = {
   //运行环境
    "env": { 
        "browser": true,//浏览器端
        "es2021": true,//es2021
    },
    //规则继承
    "extends": [ 
       //全部规则默认是关闭的,这个配置项开启推荐规则,推荐规则参照文档
       //比如:函数不能重名、对象不能出现重复key
        "eslint:recommended",
        //vue3语法规则
        "plugin:vue/vue3-essential",
        //ts语法规则
        "plugin:@typescript-eslint/recommended"
    ],
    //要为特定类型的文件指定处理器
    "overrides": [
    ],
    //指定解析器:解析器
    //Esprima 默认解析器
    //Babel-ESLint babel解析器
    //@typescript-eslint/parser ts解析器
    "parser": "@typescript-eslint/parser",
    //指定解析器选项
    "parserOptions": {
        "ecmaVersion": "latest",//校验ECMA最新版本
        "sourceType": "module"//设置为"script"（默认），或者"module"代码在ECMAScript模块中
    },
    //ESLint支持使用第三方插件。在使用插件之前，您必须使用npm安装它
    //该eslint-plugin-前缀可以从插件名称被省略
    "plugins": [
        "vue",
        "@typescript-eslint"
    ],
    //eslint规则
    "rules": {
    }
}
```

##### 1.1vue3环境代码校验插件

```
# 让所有与prettier规则存在冲突的Eslint rules失效，并使用prettier进行代码检查
"eslint-config-prettier": "^8.6.0",
"eslint-plugin-import": "^2.27.5",
"eslint-plugin-node": "^11.1.0",
# 运行更漂亮的Eslint，使prettier规则优先级更高，Eslint优先级低
"eslint-plugin-prettier": "^4.2.1",
# vue.js的Eslint插件（查找vue语法错误，发现错误指令，查找违规风格指南
"eslint-plugin-vue": "^9.9.0",
# 该解析器允许使用Eslint校验所有babel code
"@babel/eslint-parser": "^7.19.1",
```

安装指令

```
pnpm install -D eslint-plugin-import eslint-plugin-vue eslint-plugin-node eslint-plugin-prettier eslint-config-prettier eslint-plugin-node @babel/eslint-parser
```

##### 1.2修改.eslintrc.cjs配置文件

```
// @see https://eslint.bootcss.com/docs/rules/

module.exports = {
  env: {
    browser: true,
    es2021: true,
    node: true,
    jest: true,
  },
  /* 指定如何解析语法 */
  parser: 'vue-eslint-parser',
  /** 优先级低于 parse 的语法解析配置 */
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    parser: '@typescript-eslint/parser',
    jsxPragma: 'React',
    ecmaFeatures: {
      jsx: true,
    },
  },
  /* 继承已有的规则 */
  extends: [
    'eslint:recommended',
    'plugin:vue/vue3-essential',
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  plugins: ['vue', '@typescript-eslint'],
  /*
   * "off" 或 0    ==>  关闭规则
   * "warn" 或 1   ==>  打开的规则作为警告（不影响代码执行）
   * "error" 或 2  ==>  规则作为一个错误（代码不能执行，界面报错）
   */
  rules: {
    // eslint（https://eslint.bootcss.com/docs/rules/）
    'no-var': 'error', // 要求使用 let 或 const 而不是 var
    'no-multiple-empty-lines': ['warn', { max: 1 }], // 不允许多个空行
    'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off',
    'no-unexpected-multiline': 'error', // 禁止空余的多行
    'no-useless-escape': 'off', // 禁止不必要的转义字符

    // typeScript (https://typescript-eslint.io/rules)
    '@typescript-eslint/no-unused-vars': 'error', // 禁止定义未使用的变量
    '@typescript-eslint/prefer-ts-expect-error': 'error', // 禁止使用 @ts-ignore
    '@typescript-eslint/no-explicit-any': 'off', // 禁止使用 any 类型
    '@typescript-eslint/no-non-null-assertion': 'off',
    '@typescript-eslint/no-namespace': 'off', // 禁止使用自定义 TypeScript 模块和命名空间。
    '@typescript-eslint/semi': 'off',

    // eslint-plugin-vue (https://eslint.vuejs.org/rules/)
    'vue/multi-word-component-names': 'off', // 要求组件名称始终为 “-” 链接的单词
    'vue/script-setup-uses-vars': 'error', // 防止<script setup>使用的变量<template>被标记为未使用
    'vue/no-mutating-props': 'off', // 不允许组件 prop的改变
    'vue/attribute-hyphenation': 'off', // 对模板中的自定义组件强制执行属性命名样式
  },
}

```

##### 1.3.eslintignore忽略文件

```
dist
node_modules
```

##### 1.4运行脚本

package.json新增两个运行脚本

- 用eslint去校验 `pnpm run lint`
- eslint自动修复 `pnpm run fix`

```
"scripts": {
    "lint": "eslint src",
    "fix": "eslint src --fix",
}
```

#### 二、配置**prettier**

有了eslint，为什么还要有prettier？eslint针对的是javascript，他是一个检测工具，包含js语法以及少部分格式问题，在eslint看来，语法对了就能保证代码正常运行，格式问题属于其次；

而prettier属于格式化工具，它看不惯格式不统一，所以它就把eslint没干好的事接着干，另外，prettier支持

包含js在内的多种语言。

总结起来，**eslint和prettier这俩兄弟一个保证js代码质量，一个保证代码美观。**

##### 2.1安装依赖包

```
pnpm install -D eslint-plugin-prettier prettier eslint-config-prettier
```

##### 2.2 .prettierrc.json添加规则

创建 .prettierrc.json配置文件，下同

```json
{
  "singleQuote": true, //单引号
  "semi": false, // 分号
  "bracketSpacing": true, 
  "htmlWhitespaceSensitivity": "ignore",
  "endOfLine": "auto",
  "trailingComma": "all",
  "tabWidth": 2 // 缩进
}
```

##### 2.3 .prettierignore忽略文件

```
/dist/*
/html/*
.local
/node_modules/**
**/*.svg
**/*.sh
/public/*
```

**通过pnpm run lint去检测语法，如果出现不规范格式,通过pnpm run fix 修改**

#### 三、配置stylelint

[stylelint](https://stylelint.io/)为css的lint工具。可格式化css代码，检查css语法错误与不合理的写法，指定css书写顺序等。

我们的项目中使用scss作为预处理器，安装以下依赖：

```
pnpm add sass sass-loader stylelint postcss postcss-scss postcss-html stylelint-config-prettier stylelint-config-recess-order stylelint-config-recommended-scss stylelint-config-standard stylelint-config-standard-vue stylelint-scss stylelint-order stylelint-config-standard-scss -D
```

##### 3.1`.stylelintrc.cjs`**配置文件**

**官网:https://stylelint.bootcss.com/**

```
// @see https://stylelint.bootcss.com/

module.exports = {
  extends: [
    'stylelint-config-standard', // 配置stylelint拓展插件
    'stylelint-config-html/vue', // 配置 vue 中 template 样式格式化
    'stylelint-config-standard-scss', // 配置stylelint scss插件
    'stylelint-config-recommended-vue/scss', // 配置 vue 中 scss 样式格式化
    'stylelint-config-recess-order', // 配置stylelint css属性书写顺序插件,
    'stylelint-config-prettier', // 配置stylelint和prettier兼容
  ],
  overrides: [
    {
      files: ['**/*.(scss|css|vue|html)'],
      customSyntax: 'postcss-scss',
    },
    {
      files: ['**/*.(html|vue)'],
      customSyntax: 'postcss-html',
    },
  ],
  ignoreFiles: [
    '**/*.js',
    '**/*.jsx',
    '**/*.tsx',
    '**/*.ts',
    '**/*.json',
    '**/*.md',
    '**/*.yaml',
  ],
  /**
   * null  => 关闭该规则
   * always => 必须
   */
  rules: {
    'value-keyword-case': null, // 在 css 中使用 v-bind，不报错
    'no-descending-specificity': null, // 禁止在具有较高优先级的选择器后出现被其覆盖的较低优先级的选择器
    'function-url-quotes': 'always', // 要求或禁止 URL 的引号 "always(必须加上引号)"|"never(没有引号)"
    'no-empty-source': null, // 关闭禁止空源码
    'selector-class-pattern': null, // 关闭强制选择器类名的格式
    'property-no-unknown': null, // 禁止未知的属性(true 为不允许)
    'block-opening-brace-space-before': 'always', //大括号之前必须有一个空格或不能有空白符
    'value-no-vendor-prefix': null, // 关闭 属性值前缀 --webkit-box
    'property-no-vendor-prefix': null, // 关闭 属性前缀 -webkit-mask
    'selector-pseudo-class-no-unknown': [
      // 不允许未知的选择器
      true,
      {
        ignorePseudoClasses: ['global', 'v-deep', 'deep'], // 忽略属性，修改element默认样式的时候能使用到
      },
    ],
  },
}
```

##### 3.2.stylelintignore忽略文件

```
/node_modules/*
/dist/*
/html/*
/public/*
```

##### 3.3运行脚本

```
"scripts": {
	"lint:style": "stylelint src/**/*.{css,scss,vue} --cache --fix"
}
```

最后配置统一的prettier来格式化我们的js和css，html代码

```
 "scripts": {
    "dev": "vite --open",
    "build": "vue-tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint src",
    "fix": "eslint src --fix",
    "format": "prettier --write \"./**/*.{html,vue,ts,js,json,md}\"",
    "lint:eslint": "eslint src/**/*.{ts,vue} --cache --fix",
    "lint:style": "stylelint src/**/*.{css,scss,vue} --cache --fix"
  },
```

**当我们运行`pnpm run format`的时候，会把代码直接格式化**

#### 四、配置husky

在上面我们已经集成好了我们代码校验工具，但是需要每次手动的去执行命令才会格式化我们的代码。如果有人没有格式化就提交了远程仓库中，那这个规范就没什么用。所以我们需要强制让开发人员按照代码规范来提交。

要做到这件事情，就需要利用husky在代码提交之前触发git hook(git在客户端的钩子)，然后执行`pnpm run format`来自动的格式化我们的代码。

安装`husky`

```
pnpm install -D husky
```

执行

```
npx husky-init
```

会在根目录下生成个一个.husky目录，在这个目录下面会有一个pre-commit文件，这个文件里面的命令在我们执行commit的时候就会执行

在`.husky/pre-commit`文件添加如下命令：

```
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"
pnpm run format
```

当我们对代码进行commit操作的时候，就会执行命令，对代码进行格式化，然后再提交。

#### 五、配置commitlint

对于我们的commit信息，也是有统一规范的，不能随便写,要让每个人都按照统一的标准来执行，我们可以利用**commitlint**来实现。

安装包

```
pnpm add @commitlint/config-conventional @commitlint/cli -D
```

添加配置文件，新建`commitlint.config.cjs`(注意是cjs)，然后添加下面的代码：

```
module.exports = {
  extends: ['@commitlint/config-conventional'],
  // 校验规则
  rules: {
    'type-enum': [
      2,
      'always',
      [
        'feat',
        'fix',
        'docs',
        'style',
        'refactor',
        'perf',
        'test',
        'chore',
        'revert',
        'build',
      ],
    ],
    'type-case': [0],
    'type-empty': [0],
    'scope-empty': [0],
    'scope-case': [0],
    'subject-full-stop': [0, 'never'],
    'subject-case': [0, 'never'],
    'header-max-length': [0, 'always', 72],
  },
}
```

在`package.json`中配置scripts命令

```
# 在scrips中添加下面的代码
{
"scripts": {
    "commitlint": "commitlint --config commitlint.config.cjs -e -V"
  },
}
```

配置结束，现在当我们填写`commit`信息的时候，前面就需要带着下面的`subject`

```
'feat',//新特性、新功能
'fix',//修改bug
'docs',//文档修改
'style',//代码格式修改, 注意不是 css 修改
'refactor',//代码重构
'perf',//优化相关，比如提升性能、体验
'test',//测试用例修改
'chore',//其他修改, 比如改变构建流程、或者增加依赖库、工具等
'revert',//回滚到上一个版本
'build',//编译相关的修改，例如发布版本、对项目构建或者依赖的改动
```

配置husky

```
npx husky add .husky/commit-msg 
```

在生成的commit-msg文件中添加下面的命令

```
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"
pnpm commitlint
```

当我们 commit 提交信息时，就不能再随意写了，必须是 git commit -m 'fix: xxx' 符合类型的才可以，**需要注意的是类型的后面需要用英文的 :，并且冒号后面是需要空一格的，这个是不能省略的**

#### 六、强制使用pnpm包管理器工具

团队开发项目的时候，需要统一包管理器工具,因为不同包管理器工具下载同一个依赖,可能版本不一样,

导致项目出现bug问题,因此包管理器工具需要统一管理！！！

在根目录创建`scritps/preinstall.js`文件，添加下面的内容

```
if (!/pnpm/.test(process.env.npm_execpath || '')) {
  console.warn(
    `\u001b[33mThis repository must using pnpm as the package manager ` +
    ` for scripts to work properly.\u001b[39m\n`,
  )
  process.exit(1)
}
```

配置命令

```
"scripts": {
	"preinstall": "node ./scripts/preinstall.js"
}
```

**当我们使用npm或者yarn来安装包的时候，就会报错了。原理就是在install的时候会触发preinstall（npm提供的生命周期钩子）这个文件里面的代码。**

## 三、项目集成

### 3.1集成element-plus

硅谷甄选运营平台,UI组件库采用的element-plus，因此需要集成element-plus插件！！！

官网地址:https://element-plus.gitee.io/zh-CN/

**安装组件库和所有的icon**

```
pnpm install element-plus @element-plus/icons-vue
```

**入口文件main.ts全局安装element-plus,element-plus默认支持语言英语设置为中文**

```ts
import ElementPlus from 'element-plus';
import 'element-plus/dist/index.css'
//@ts-ignore忽略当前文件ts类型的检测否则有红色提示(打包会失败)
import zhCn from 'element-plus/dist/locale/zh-cn.mjs'
app.use(ElementPlus, {
    locale: zhCn
})
```

### 3.2src别名的配置

在开发项目的时候文件与文件关系可能很复杂，因此我们需要给src文件夹配置一个别名！！！

```ts
// vite.config.ts
import {defineConfig} from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'
export default defineConfig({
    plugins: [vue()],
    resolve: {
        alias: {
            "@": path.resolve("./src") // 相对路径别名配置，使用 @ 代替 src
        }
    }
})
```

**TypeScript 编译配置**

```
// tsconfig.json
{
  "compilerOptions": {
    "baseUrl": "./", // 解析非相对模块的基地址，默认是当前目录
    "paths": { //路径映射，相对于baseUrl
      "@/*": ["src/*"] 
    }
  }
}
```

### 3.3环境变量的配置

**项目开发过程中，至少会经历开发环境、测试环境和生产环境(即正式环境)三个阶段。不同阶段请求的状态(如接口地址等)不尽相同，若手动切换接口地址是相当繁琐且易出错的。于是环境变量配置的需求就应运而生，我们只需做简单的配置，把环境状态切换的工作交给代码。**

开发环境（development）
顾名思义，开发使用的环境，每位开发人员在自己的dev分支上干活，开发到一定程度，同事会合并代码，进行联调。

测试环境（testing）
测试同事干活的环境啦，一般会由测试同事自己来部署，然后在此环境进行测试

生产环境（production）
生产环境是指正式提供对外服务的，一般会关掉错误报告，打开错误日志。(正式提供给客户使用的环境。)

注意:一般情况下，一个环境对应一台服务器,也有的公司开发与测试环境是一台服务器！！！

项目根目录分别添加 开发、生产和测试环境的文件!

```
.env.development
.env.production
.env.test
```

文件内容

```
# 变量必须以 VITE_ 为前缀才能暴露给外部读取
NODE_ENV = 'development'
VITE_APP_TITLE = '硅谷甄选运营平台'
VITE_APP_BASE_API = '/dev-api'
```

```
NODE_ENV = 'production'
VITE_APP_TITLE = '硅谷甄选运营平台'
VITE_APP_BASE_API = '/prod-api'
```

```
# 变量必须以 VITE_ 为前缀才能暴露给外部读取
NODE_ENV = 'test'
VITE_APP_TITLE = '硅谷甄选运营平台'
VITE_APP_BASE_API = '/test-api'
```

配置运行命令：package.json

```
 "scripts": {
    "dev": "vite --open",
    "build:test": "vue-tsc && vite build --mode test",
    "build:pro": "vue-tsc && vite build --mode production",
    "preview": "vite preview"
  },
```

通过`import.meta.env`获取环境变量

### 3.4SVG图标配置

在开发项目的时候经常会用到svg矢量图,而且我们使用SVG以后，页面上加载的不再是图片资源,

这对页面性能来说是个很大的提升，而且我们SVG文件比img要小的很多，放在项目中几乎不占用资源。

**安装SVG依赖插件**

```
pnpm install vite-plugin-svg-icons -D
```

**在`vite.config.ts`中配置插件**

```js
import { createSvgIconsPlugin } from 'vite-plugin-svg-icons'
import path from 'path'
export default () => {
  return {
    plugins: [
      createSvgIconsPlugin({
        // Specify the icon folder to be cached
        iconDirs: [path.resolve(process.cwd(), 'src/assets/icons')],
        // Specify symbolId format
        symbolId: 'icon-[dir]-[name]',
      }),
    ],
  }
}
```

**入口文件导入**

```
import 'virtual:svg-icons-register'
```

#### 3.4.1svg封装为全局组件

因为项目很多模块需要使用图标,因此把它封装为全局组件！！！

**在src/components目录下创建一个SvgIcon组件:代表如下**

```vue
<template>
  <div>
    <svg :style="{ width: width, height: height }">
      <use :xlink:href="prefix + name" :fill="color"></use>
    </svg>
  </div>
</template>

<script setup lang="ts">
defineProps({
  //xlink:href属性值的前缀
  prefix: {
    type: String,
    default: '#icon-'
  },
  //svg矢量图的名字
  name: String,
  //svg图标的颜色
  color: {
    type: String,
    default: ""
  },
  //svg宽度
  width: {
    type: String,
    default: '16px'
  },
  //svg高度
  height: {
    type: String,
    default: '16px'
  }

})
</script>
<style scoped></style>
```

在src文件夹目录下创建一个index.ts文件：用于注册components文件夹内部全部全局组件！！！

```ts
//引入项目中全部的全局组件
import SvgIcon from '@/components/SvgIcon/index.vue'
//全局对象
const allGlobalComponent: any = { SvgIcon }
export default {
  install(app: any) {
    Object.keys(allGlobalComponent).forEach((key) => {
      app.component(key, allGlobalComponent[key])
    })
  },
}
```

在入口文件引入src/index.ts文件,通过app.use方法安装自定义插件

```
import gloablComponent from './components/index';
app.use(gloablComponent);
```

### 3.5集成sass

我们目前在组件内部已经可以使用scss样式,因为在配置styleLint工具的时候，项目当中已经安装过sass sass-loader,因此我们再组件内可以使用scss语法！！！需要加上lang="scss"

```
<style scoped lang="scss"></style>
```

接下来我们为项目添加一些全局的样式

在src/styles目录下创建一个index.scss文件，当然项目中需要用到清除默认样式，因此在index.scss引入reset.scss

```
@import reset.scss
```

在入口文件引入

```
import '@/styles'
```

但是你会发现在src/styles/index.scss全局样式文件中没有办法使用$变量.因此需要给项目中引入全局变量$.

在style/variable.scss创建一个variable.scss文件！

在vite.config.ts文件配置如下:

```ts
export default defineConfig((config) => {
	css: {
      preprocessorOptions: {
        scss: {
          javascriptEnabled: true,
          additionalData: '@import "./src/styles/variable.scss";',
        },
      },
    },
	}
}
```

**`@import "./src/styles/variable.less";`后面的`;`不要忘记，不然会报错**!

配置完毕你会发现scss提供这些全局变量可以在组件样式中使用了！！！

### 3.6mock数据

安装依赖:https://www.npmjs.com/package/vite-plugin-mock

```
pnpm install -D vite-plugin-mock mockjs
```

在 vite.config.js 配置文件启用插件。

```ts
import { UserConfigExport, ConfigEnv } from 'vite'
import { viteMockServe } from 'vite-plugin-mock'
import vue from '@vitejs/plugin-vue'
export default ({ command })=> {
  return {
    plugins: [
      vue(),
      viteMockServe({
        localEnabled: command === 'serve',
      }),
    ],
  }
}
```

在根目录创建mock文件夹:去创建我们需要mock数据与接口！！！

在mock文件夹内部创建一个user.ts文件

```ts
//用户信息数据
function createUserList() {
    return [
        {
            userId: 1,
            avatar:
                'https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif',
            username: 'admin',
            password: '111111',
            desc: '平台管理员',
            roles: ['平台管理员'],
            buttons: ['cuser.detail'],
            routes: ['home'],
            token: 'Admin Token',
        },
        {
            userId: 2,
            avatar:
                'https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif',
            username: 'system',
            password: '111111',
            desc: '系统管理员',
            roles: ['系统管理员'],
            buttons: ['cuser.detail', 'cuser.user'],
            routes: ['home'],
            token: 'System Token',
        },
    ]
}

export default [
    // 用户登录接口
    {
        url: '/api/user/login',//请求地址
        method: 'post',//请求方式
        response: ({ body }) => {
            //获取请求体携带过来的用户名与密码
            const { username, password } = body;
            //调用获取用户信息函数,用于判断是否有此用户
            const checkUser = createUserList().find(
                (item) => item.username === username && item.password === password,
            )
            //没有用户返回失败信息
            if (!checkUser) {
                return { code: 201, data: { message: '账号或者密码不正确' } }
            }
            //如果有返回成功信息
            const { token } = checkUser
            return { code: 200, data: { token } }
        },
    },
    // 获取用户信息
    {
        url: '/api/user/info',
        method: 'get',
        response: (request) => {
            //获取请求头携带token
            const token = request.headers.token;
            //查看用户信息是否包含有次token用户
            const checkUser = createUserList().find((item) => item.token === token)
            //没有返回失败的信息
            if (!checkUser) {
                return { code: 201, data: { message: '获取用户信息失败' } }
            }
            //如果有返回成功信息
            return { code: 200, data: {checkUser} }
        },
    },
]
```

**安装axios**

```
pnpm install axios
```

最后通过axios测试接口！！！

### 3.7axios二次封装

在开发项目的时候避免不了与后端进行交互,因此我们需要使用axios插件实现发送网络请求。在开发项目的时候

我们经常会把axios进行二次封装。

目的:

1:使用请求拦截器，可以在请求拦截器中处理一些业务(开始进度条、请求头携带公共参数)

2:使用响应拦截器，可以在响应拦截器中处理一些业务(进度条结束、简化服务器返回的数据、处理http网络错误)

在根目录下创建utils/request.ts

```js
import axios from "axios";
import { ElMessage } from "element-plus";
//创建axios实例
let request = axios.create({
    baseURL: import.meta.env.VITE_APP_BASE_API,
    timeout: 5000
})
//请求拦截器
request.interceptors.request.use(config => {
    return config;
});
//响应拦截器
request.interceptors.response.use((response) => {
    return response.data;
}, (error) => {
    //处理网络错误
    let msg = '';
    let status = error.response.status;
    switch (status) {
        case 401:
            msg = "token过期";
            break;
        case 403:
            msg = '无权访问';
            break;
        case 404:
            msg = "请求地址错误";
            break;
        case 500:
            msg = "服务器出现问题";
            break;
        default:
            msg = "无网络";

    }
    ElMessage({
        type: 'error',
        message: msg
    })
    return Promise.reject(error);
});
export default request;
```

### 3.8API接口统一管理

在开发项目的时候,接口可能很多需要统一管理。在src目录下去创建api文件夹去统一管理项目的接口；

新建user文件夹，管理用户有关接口

index.ts

```ts
//统一管理项目用户相关的接口
import request from '@/utils/request.ts'
import type { loginForm, loginResponseData, userResponseData } from './type'

enum API {
  LOGIN_URL = '/user/login',
  USERINFO_URL = '/user/info',
}

export const reqLogin = (data: loginForm) =>
  //any限制data，loginResponseData限制后端返回类型
  request.post<any, loginResponseData>(API.LOGIN_URL, data)

export const reqUserInfo = () =>
  request.get<any, userResponseData>(API.USERINFO_URL)
```

type.ts

```ts
// 登录接口需要携带参数ts类型
export interface loginForm {
  username: string
  password: string
}
interface dataType {
  token?: string
  message?: string //问号代表可选
}
//登录接口返回数据类型
export interface loginResponseData {
  code: number
  data: dataType
}
interface userInfo {
  userId: number
  avatar: string
  username: string
  password: string
  desc: string
  roles: string[]
  buttons: string[]
  routes: string[]
  token: string
}
interface user {
  checkUser: userInfo
}
//定义服务器返回用户信息相关数据类型
export interface userResponseData {
  code: number
  data: user
}
```

## 四、项目开发

### 配置路由

首先安装路由

```shell
pnpm install vue-router
```

然后创建views文件夹用于存放具体页面，此文件夹下新建404、home、login文件夹

各文件夹新建index.vue文件

在src目录下新建router文件夹，用于存放路由表，router文件夹新建index.ts和routes.ts文件如下

```ts
//通过vue-router插件实现模板路由配置
import { createRouter, createWebHashHistory } from 'vue-router'
import { constantRoute } from '@/router/routes.ts'
const router = createRouter({
  history: createWebHashHistory(),
  routes: constantRoute,
  scrollBehavior() {
    return {
      left: 0,
      top: 0,
    }
  },
})

export default router
```

```ts
export const constantRoute = [
  {
    path: '/login',
    component: () => import('@/views/login/index.vue'),
    name: 'login',
  },
  {
    path: '/',
    component: () => import('@/views/home/index.vue'),
    name: 'home',
  },
  {
    path: '/404',
    component: () => import('@/views/404/index.vue'),
    name: '404',
  },
  {
    path: '/:pathMatch(.*)*',
    redirect: '/404',
    name: 'Any',
  },
]
```

`path: '/:pathMatch(.*)*'` 是一个特殊的路由配置，它可以用于捕获任意路径并进行路由重定向。让我们来详细讲解这个配置：

1. `path: '/:pathMatch(.*)*' `中的 path 表示该路由的路径，这里是 /，意味着它匹配根路径。

2. `:pathMatch(.*)* `是一个动态片段，它使用了路由参数（以冒号 : 开头），其中 pathMatch 是参数的名称，而 (.*)* 是参数的正则表达式模式。

   * `(.*)` 是一个正则表达式，它匹配任意字符（零次或多次）。这意味着它可以捕获任何路径片段。

   * `*`表示捕获的路径片段可以重复零次或多次。这允许我们捕获整个路径。

所以，`/:pathMatch(.*)* `可以匹配任意路径，包括根路径和子路径。

### 登录

src/views/login/index.vue

```vue
<script setup lang="ts">
//从element-plus的icons-vue库中引入User图标，这是一个组件，注意动态绑定
import { User, Lock } from '@element-plus/icons-vue'
//引入用户相关小仓库
import useUserStore from '@/store/modules/user.ts'
import { ref, reactive } from 'vue'
//引入useRouter函数，编程导航
import { useRouter } from 'vue-router'
//登录成功/失败消息提示框
import { ElNotification } from 'element-plus'
//获取时间
import { getTime } from '@/utils/time.ts'

//收集账号与密码的数据
let loginForm = reactive({ username: 'admin', password: '111111' })
let useStore = useUserStore()
//获取路由器
let $router = useRouter()
//按钮加载状态，当为true时，会显示一个小齿轮正在加载，
//当执行点击事件后，此值应该变为true，当执行完后，无论结果如何，变成false
let loading = ref(false)
const login = () => {
  //点击登录按钮后，通知仓库发登录请求
  //请求成功->首页 请求失败->弹出登录失败信息
  loading.value = true
  useStore
    .userLogin(loginForm)
    .then(() => {
      $router.push('/')
      ElNotification({
        type: 'success',
        message: `欢迎${loginForm.username}登录`,
        title: `Hi ${getTime()}好`,
      })
    })
    .catch((error) => {
      ElNotification({
        type: 'error',
        message: error.message,
      })
    })
    .finally(() => {
      loading.value = false
    })
}
</script>

<template>
  <div class="login_container">
    <el-row>
      <el-col :span="12" :xs="0"></el-col>
      <el-col :span="12" :xs="24">
        <el-form class="login_form">
          <h1>Hello</h1>
          <h2>hello world</h2>
          <el-form-item>
            <el-input
              :prefix-icon="User"
              v-model="loginForm.username"
            ></el-input>
          </el-form-item>
          <el-form-item>
            <!--prefix-icon是前缀图标 show-password是后缀密码框中小眼睛图标用于显示/隐藏密码-->
            <el-input
              :prefix-icon="Lock"
              type="password"
              v-model="loginForm.password"
              show-password
            ></el-input>
          </el-form-item>
          <el-form>
            <!--click绑定登录事件-->
            <el-button
              :loading="loading"
              class="login_btn"
              type="primary"
              size="default"
              @click="login"
            >
              登录
            </el-button>
          </el-form>
        </el-form>
      </el-col>
    </el-row>
  </div>
</template>

<style scoped lang="scss">
.login_container {
  width: 100%;
  height: 100vh;
  //不使用 no-repeat，背景图片默认会在水平和垂直方向上重复平铺以填充整个背景区域
  background: url('@/assets/images/background.jpg') no-repeat;
  background-size: cover; //告诉浏览器要将背景图片等比例缩放，以覆盖整个区域
  .login_form {
    position: relative;
    width: 80%;
    top: 30vh; //注意设置top，需要定位
    background: url('@/assets/images/login_form.png') no-repeat;
    background-size: cover;
    padding: 40px;
    h1 {
      color: white;
      font-size: 40px;
    }
    h2 {
      font-size: 20px;
      color: white;
      margin: 20px 0;
    }
    .login_btn {
      width: 100%;
    }
  }
}
</style>
```

新建src/store文件夹

index.ts

```ts
//创建大仓库
import { createPinia } from 'pinia'
const store = createPinia()
//对外暴露，安装仓库
export default store
```

新建src/store/modules,此文件夹用于各个小仓库存放

user.ts

```ts
//创建用户相关的小仓库
import { defineStore } from 'pinia'
//引入登录请求接口
import { reqLogin } from '@/api/user'
//引入登录数据类型
import { loginForm } from '@/api/user/type.ts'
//引入本地存储相关方法
import { GET_TOKEN, SET_TOKEN } from '@/utils/token.ts'

const useUserStore = defineStore('User', () => {
  let token = GET_TOKEN() //用户唯一标识token，放在本地存储
  return {
    async userLogin(data: loginForm) {
      //用户登录方法 这是一个异步方法，用async标识，await用于等待调用的完成再执行下面的代码
      //async标识的函数会返回一个promise
      const result = await reqLogin(data)
      //登录成功200-》token 失败-》登录失败错误信息
      if (result.code === 200) {
        //pinia仓库存储token
        token = result.data.token as string
        //本地存储持久化token
        SET_TOKEN(token)
        //这个返回能保证async函数返回一个成功的promise，这个会显示在promise.result中
        return 'ok'
      } else {
        //这个会显示在promise.result中
        return Promise.reject(new Error(result.data.message))
      }
    },
  }
})
export default useUserStore
```

在utils目录下新建token.ts用于封装本地存储数据相关方法

```ts
//封装本地存储 存储数据与读取数据方法
export const SET_TOKEN = (token: string) => {
  localStorage.setItem('TOKEN', token)
}
export const GET_TOKEN = () => {
  return localStorage.getItem('TOKEN')
}
```

在utils目录下新建time.ts用于封装获取时间方法

```ts
export const getTime = () => {
  const time = new Date().getHours()
  return time <= 6
    ? '凌晨'
    : time <= 12
      ? '上午'
      : time <= 18
        ? '下午'
        : time <= 24
          ? '晚上'
          : 'wrong'
}
```

#### 登录表单字段校验

在login/index.vue的template中el-form标签绑定

```
:model="loginForm" //获取表单输入
:rules="rules" //表单校验规则
ref="ruleLoginForm" //表单实例

el-form-item绑定prop，对应rules对象key
```

在login/index.vue的script中

```js
//收集账号与密码的数据
let loginForm = reactive({ username: 'admin', password: '111111' })
//获得表单组件，判断校验是否通过 await ruleLoginForm.value.validate()
let ruleLoginForm = ref()
//变量/参数前面加下划线，标识未使用变量/参数，规避错误提示
const validatePass = (_rule: any, value: any, callback: any) => {
  //rule:即为校验对象
  //value：即为表单元素对象
  //callback函数：如果符合条件直接callback()放行即可
  //否则注入错误信息
  if (value.length >= 5) {
    callback()
  } else {
    callback(new Error('用户名需大于等于5位'))
  }
}
const validatePass2 = (_rule: any, value: any, callback: any) => {
  if (value.length >= 6) {
    callback()
  } else {
    callback(new Error('密码需大于等于6位'))
  }
}
//定义表单校验需要配置对象
const rules = {
  //规则对象属性
  //required，代表这个字段必须校验
  //min，文本长度至少多少位
  //max，文本长度至多多少位
  //message，错误提示信息
  //trigger，触发校验的时机 blur：失去焦点 change：更改
  username: [{ validator: validatePass, trigger: 'change' }],
  password: [{ validator: validatePass2, trigger: 'change' }],
}
```

然后修改login方法，确保校验通过再请求

```js
const login = async () => {
  //保证表单校验通过，点击按钮才会提交请求
  await ruleLoginForm.value.validate()
  //点击登录按钮后，通知仓库发登录请求
  //请求成功->首页 请求失败->弹出登录失败信息
  loading.value = true
  useStore
    .userLogin(loginForm)
    .then(() => {
      $router.push('/')
      ElNotification({
        type: 'success',
        message: `欢迎${loginForm.username}登录`,
        title: `Hi ${getTime()}好`,
      })
    })
    .catch((error) => {
      ElNotification({
        type: 'error',
        message: error.message,
      })
    })
    .finally(() => {
      loading.value = false
    })
}
```

#### 登录业务中技巧总结

**element-plus**

组件默认使用flex布局，而且是分为24个部分,通过span属性即可指定列占几部分

```html
<el-row>
    <el-col :span="12"><div class="grid-content ep-bg-purple" /></el-col>
    <el-col :span="12"><div class="grid-content ep-bg-purple-light" /></el-col>
</el-row>

<!--
<el-row :gutter="20">
    
</el-row>
-->
```

可以在`<el-row>`上绑定`gutter`属性来指定列间距，默认为0

element也提供了container常见布局，[详见](https://element-plus.gitee.io/zh-CN/component/container.html)

### layout 主页

#### 主页布局

新建layout文件夹用于布局

其中新建index.vue

```vue
<script setup lang="ts"></script>

<template>
  <div class="layout_container">
    <!--左侧菜单-->
    <div class="layout_aside">123</div>
    <!--顶部导航-->
    <div class="layout_header">456</div>
    <!--内容展示-->
    <div class="layout_main">
      <p style="height: 1000px">789</p>
    </div>
  </div>
</template>

<style scoped lang="scss">
.layout_container {
  width: 100%;
  height: 100vh;
  background: gold;
  .layout_aside {
    width: $base_aside_width;
    height: 100vh;
    background: $base_aside_background;
  }
  .layout_header {
    position: fixed;
    width: calc(
      100% - $base_aside_width
    ); // 注意calc中减号要空格，这个函数支持百分比等形式加减
    height: $base_header_height;
    background: purple;
    top: 0px;
    left: $base_aside_width;
    border-bottom: rgba(0, 0, 0, 0.15) solid 1px;
  }
  .layout_main {
    position: absolute;
    width: calc(100% - $base_aside_width);
    height: calc(100vh - $base_header_height);
    background: white;
    top: $base_header_height;
    left: $base_aside_width;
    padding: 20px;
    overflow: auto; //当内容超出时，在区域内滚动，而不是超出区域
  }
}
</style>
```

更改routes.ts中的路由

```ts
{
    path: '/',
    component: () => import('@/layout/index.vue'),
    name: 'home',
},
```

增加全局滚动条样式 styles/index.css

```css
@import "reset";

//滚动条样式设置
::-webkit-scrollbar {
  width: 10px;
  height: 4px;
}

::-webkit-scrollbar-thumb {
  border-radius: 5px;
  -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
  background-color: #99a9bf;
}

::-webkit-scrollbar-track {
  -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
  border-radius: 5px;
  background-color: #d3dce6;
}
```

#### 左侧顶部菜单logo组件

components目录下新建logo文件夹，里面新建index.vue

```vue
<script setup lang="ts">
import setting from '@/setting.ts'
</script>

<template>
  <div class="logo" v-if="!setting.logoHidden">
    <img :src="setting.logo" alt="logo" />
    <p>{{ setting.title }}</p>
  </div>
</template>

<style scoped lang="scss">
.logo {
  width: 100%;
  height: $base_menu_logo_height;
  color: white;
  display: flex;
  align-items: center;
  padding: 20px;
  img {
    width: 35px;
    height: 35px;
  }
  p {
    font-size: $base_menu_title_fontsize;
    margin-left: 10px;
  }
}
</style>
```

在src目录下新建setting.ts，方便修改一些样式

```ts
//一些全局设置，包括logo，系统名字等等
export default {
  title: '硅谷甄选', //项目标题
  logo: '/public/logo.jpg', //项目logo
  logoHidden: false, //是否隐藏
}
```

#### 40 递归组件生成动态菜单

首先给routes.ts中添加meta源信息，考虑到需要有标题以及是否隐藏，所以有两个字段

```ts
export const constantRoute = [
  {
    path: '/login',
    component: () => import('@/views/login/index.vue'),
    name: 'login',
    meta: {
      title: '登录', //路由元信息
      hidden: true,
    },
  },
  {
    path: '/',
    component: () => import('@/layout/index.vue'),
    name: 'layout',
    meta: {
      title: 'layout',
      hidden: false,
    },
    children: [
      {
        path: '/home',
        component: () => import('@/views/home/index.vue'),
        meta: {
          title: '首页',
          hidden: false,
        },
      },
      {
        path: '/ceshi',
        component: () => import('@/views/home/index.vue'),
        meta: {
          title: '测试',
          hidden: false,
        },
      },
    ],
  },
  {
    path: '/404',
    component: () => import('@/views/404/index.vue'),
    name: '404',
    meta: {
      title: '404',
      hidden: true,
    },
  },
  {
    path: '/:pathMatch(.*)*',
    redirect: '/404',
    name: 'Any',
    meta: {
      title: 'any',
      hidden: true,
    },
  },
]
```

因为el-menu右侧会有一个边界线border，在layout.vue中去除

```css
.scrollbar {
    width: 100%;
    height: calc(100vh - $base_menu_logo_height);
    //去除边界线
    .el-menu {
        border-right: none;
    }
}
```

引入常量路由，因为可能会有异步，所以不能直接在组件里引，放在定义的仓库即userStore中

/store/modules/user.ts

```ts
+import { constantRoute } from '@/router/routes.ts'
+import { reactive } from 'vue'
const useUserStore = defineStore('User', () => {
  ....
+  const menuRoutes = reactive(constantRoute)
  return {
    ......
+   menuRoutes,
  }
})
```

在layout文件夹下新建menu文件夹，内建index.vue。

```vue
<script setup lang="ts">
//获取父组件传递过来的全部路由数组
defineProps(['menuList'])
</script>
<script lang="ts">
export default {
  // eslint-disable-next-line vue/no-reserved-component-names
  name: 'Menu',
}
</script>

<template>
  <template v-for="item in menuList" :key="item.path">
    <!--判断是否隐藏-->
    <template v-if="!item.meta.hidden">
      <!--如果item没有一个孩子，直接展示-->
      <el-menu-item v-if="!item.children" :index="item.path">
        <template #title>{{ item.meta.title }}</template>
      </el-menu-item>
      <!--如果item只有一个孩子，直接展示-->
      <el-menu-item
        v-if="item.children && item.children.length == 1"
        :index="item.path"
      >
        <template #title>
          {{ item.children[0].meta.title }}
        </template>
      </el-menu-item>

      <!--如果item有多个孩子，折叠展示-->
      <el-sub-menu
        v-if="item.children && item.children.length > 1"
        :index="item.path"
      >
        <template #title>
          {{ item.meta.title }}
        </template>
        <!--因为是树形结构，万一嵌套多次没法每次重写遍历，所以使用递归组件-->
        <Menu :menuList="item.children"></Menu>
      </el-sub-menu>
    </template>
  </template>
</template>

<style scoped lang="scss"></style>
```

其中有一点注意

* 首先是递归组件的使用，其次注意递归组件需要在组件内对外暴露名字才可以正常使用

#### 41 菜单图标 全局注册

使用element-plus中的icon图标，首先全局注册它们

之前在 /components文件夹下index.ts中全局注册了一些组件，同样在该文件继续注册

```ts
//引入全部图标组件
+import * as ElementPlusIconsVue from '@element-plus/icons-vue'
export default {
	.......
+    for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
+      app.component(key, component)
+    }
  },
}
```

在menu文件夹下index.vue中补全图标，以及点击事件

```html
<template v-if="!item.meta.hidden">
    <!--如果item没有一个孩子，直接展示-->
+    <el-menu-item v-if="!item.children" :index="item.path" @click="goRoute">
        <template #title>
+            <el-icon>
+                <component :is="item.meta.icon"></component>
+            </el-icon>
+            <span>{{ item.meta.title }}</span>
        </template>
    </el-menu-item>
    <!--如果item只有一个孩子，直接展示-->
+    <el-menu-item
                  v-if="item.children && item.children.length == 1"
                  :index="item.path"
                  @click="goRoute"
                  >
        <template #title>
+            <el-icon>
+                <component :is="item.children[0].meta.icon"></component>
+            </el-icon>
+           <span>{{ item.children[0].meta.title }}</span>
        </template>
    </el-menu-item>

    <!--如果item有多个孩子，折叠展示-->
    <el-sub-menu
                 v-if="item.children && item.children.length > 1"
                 :index="item.path"
                 >
        <template #title>
+            <el-icon>
+                <component :is="item.meta.icon"></component>
+            </el-icon>
+            <span>{{ item.meta.title }}</span>
        </template>
        <!--因为是树形结构，万一嵌套多次没法每次重写遍历，所以使用递归组件-->
        <Menu :menuList="item.children"></Menu>
    </el-sub-menu>
</template>
```

在routes.ts中补全图标名字

```ts
  {
    path: '/',
    component: () => import('@/layout/index.vue'),
    name: 'layout',
    meta: {
      title: 'layout',
      hidden: false,
+      icon: 'Avatar',
    },
    children: [
      {
        path: '/home',
        component: () => import('@/views/home/index.vue'),
        meta: {
          title: '首页',
          hidden: false,
+          icon: 'HomeFilled',
        },
      },
    ],
  },
```

**重点:**

* 使用`<component :is="item.meta.icon"></component>`标签来动态加载组件

#### 42 项目路由配置

首先在views文件夹下新建acl和product和screen，分别是权限管理、商品管理、以及数据大屏,具体结构如下所示

```
acl
	permission
		index.vue
	role
		index.vue
	user
		index.vue
product
	attr
	 	index.vue
	sku
		index.vue
	spu
		index.vue
	trademark
		index.vue
screen
	index.vue
```

在routes.vue中添加对应路由

```ts
  {
    path: '/screen',
    component: () => import('@/views/screen/index.vue'),
    name: 'Screen',
    meta: {
      title: '数据大屏',
      hidden: false,
      icon: 'Platform',
    },
  },
  {
    path: '/acl',
    component: () => import('@/layout/index.vue'), // 因为骨架仍然是layout
    name: 'Acl',
    meta: {
      title: '权限管理',
      hidden: false,
      icon: 'Lock',
    },
    children: [
      {
        //注意这里要写绝对路径，因为因为在动态菜单使用的是我们定义的路由数组，不会自动拼接路径，
        //在路由跳转的时候会用到我们现在定义的绝对路径跳转，否则需要再拼接。
        path: '/acl/user',
        component: () => import('@/views/acl/user/index.vue'),
        name: 'User',
        meta: {
          hidden: false,
          title: '用户管理',
          icon: 'User',
        },
      },
      {
        path: '/acl/role',
        component: () => import('@/views/acl/role/index.vue'),
        name: 'Role',
        meta: {
          hidden: false,
          title: '角色管理',
          icon: 'UserFilled',
        },
      },
      {
        path: '/acl/permission',
        component: () => import('@/views/acl/permission/index.vue'),
        name: 'Permission',
        meta: {
          hidden: false,
          title: '菜单管理',
          icon: 'Monitor',
        },
      },
    ],
  },
  {
    path: '/product',
    component: () => import('@/layout/index.vue'),
    name: 'Product',
    meta: {
      title: '商品管理',
      hidden: false,
      icon: 'Goods',
    },
    redirect: '/product/trademark',
    children: [
      {
        path: '/product/trademark',
        component: () => import('@/views/product/trademark/index.vue'),
        name: 'Trademark',
        meta: {
          title: '品牌管理',
          icon: 'ShoppingCart',
          hidden: false,
        },
      },
      {
        path: '/product/attr',
        component: () => import('@/views/product/attr/index.vue'),
        name: 'Attr',
        meta: {
          title: '属性管理',
          icon: 'Management',
          hidden: false,
        },
      },
      {
        path: '/product/spu',
        component: () => import('@/views/product/spu/index.vue'),
        name: 'Spu',
        meta: {
          title: 'Spu',
          icon: 'SetUp',
          hidden: false,
        },
      },
      {
        path: '/product/sku',
        component: () => import('@/views/product/sku/index.vue'),
        name: 'Sku',
        meta: {
          title: 'Sku',
          icon: 'ScaleToOriginal',
          hidden: false,
        },
      },
    ],
  },
```

在 / 路由下新增

```ts
{
    path: '/',
	......
+    redirect: '/home',
    children: [
      .....
    ],
  },
```

重定向使得当登录跳转过来内容区直接显示首页即home的内容

在layout文件夹下新建main文件夹，封装内容组件，从而添加过渡动画

```vue
<script setup lang="ts"></script>

<template>
  <!-- 路由组件出口的位置 -->
  <router-view v-slot="{ Component }">
    <!-- 加上这段，可以实现动画效果 -->
    <transition name="fade">
      <!-- 渲染一级路由的子路由 即内容区 -->
      <component :is="Component" />
    </transition>
  </router-view>
</template>

<style scoped lang="scss">
//组件刚进入时 不可见
.fade-enter-from {
  opacity: 0;
}
//需要的时间 0.3s
.fade-enter-active {
  transition: all 0.3s;
}
//组件进入后 可见
.fade-enter-to {
  opacity: 1;
}
</style>
```

在layout文件夹下index.vue中引入main组件并在内容区显示

```html
<!--内容展示-->
<div class="layout_main">
+    <Main></Main>
</div>
```

在menu文件夹下index中添加点击菜单的事件，即内容区显示不同组件，

```js
import { useRouter } from 'vue-router'
//获取父组件传递过来的全部路由数组
defineProps(['menuList'])
let $router = useRouter()
//vc是el-menu-item实例,有index字段,此字段在先前绑定了item.path，故可以使用
const goRoute = (vc: any) => {
  $router.push(vc.index)
}
```

#### 43 顶部tabbar组件静态与拆分

当折叠时，会把图标也折叠，需要将el-icon放在template外面

*layout/menu/index*

```html
<el-icon>
    <component :is="item.meta.icon"></component>
</el-icon>
<template #title>
    <span>{{ item.meta.title }}</span>
</template>
```

当点击二级菜单项后再点击刷新菜单会折叠，在el-menu上绑定default-active属性使其刷新时不折叠

*layout/menu/index*

```html
<el-menu
  :default-active="$route.path"
  background-color="#001529"
  text-color="white"
>
```

```
useRoute():返回当前的路由地址。相当于在模板中使用 $route。
useRouter():返回路由器实例。相当于在模板中使用 $router。
```

layout下新建tabbar文件夹，其内新建index.vue和breadcrumb及setting文件夹

*index.vue*

```vue
<script setup lang="ts">
import Breadcrumb from '@/layout/tabbar/breadcrumb/index.vue'
import Setting from '@/layout/tabbar/setting/index.vue'
</script>

<template>
  <div class="tabbar">
    <div class="tabbar_left">
      <Breadcrumb></Breadcrumb>
    </div>
    <div class="tabber_right">
      <Setting></Setting>
    </div>
  </div>
</template>

<style scoped lang="scss">
.tabbar {
  width: 100%;
  height: 100%;
  display: flex; //在不设置flex方向时，默认主轴是水平轴，交叉轴是垂直轴
  justify-content: space-between; //主轴对齐使用justify-content，垂直轴对齐使用align-items
  align-items: center;
  .tabbar_left {
    display: flex;
    margin-left: 20px;
    align-items: center;
  }
  .tabbar_right {
    display: flex;
    align-items: center;
  }
}
</style>
```

*setting/index.vue*

```vue
<script setup lang="ts"></script>

<template>
  <el-button size="small" icon="Refresh" circle></el-button>
  <el-button size="small" icon="FullScreen" circle></el-button>
  <el-button size="small" icon="Setting" circle></el-button>
  <img
    src="../../../public/logo.jpg"
    style="width: 24px; height: 24px; margin: 0px 10px;vertical-align: top"
  />
  <!--下拉菜单-->
  <el-dropdown trigger="hover">
    <span class="el-dropdown-link" style="vertical-align: top">
      admin
      <el-icon class="el-icon--right"><arrow-down /></el-icon>
    </span>
    <template #dropdown>
      <el-dropdown-menu>
        <el-dropdown-item icon="SwitchButton">退出登录</el-dropdown-item>
      </el-dropdown-menu>
    </template>
  </el-dropdown>
</template>

<style scoped lang="scss"></style>
```

*breadcrumb/index.vue*

```vue
<script setup lang="ts"></script>

<template>
  <!--顶部左侧静态-->
  <el-icon style="margin-right: 10px">
    <Expand />
  </el-icon>
  <!--左侧面包屑-->
  <el-breadcrumb separator-icon="ArrowRight">
    <el-breadcrumb-item :to="{ path: '/' }">homepage</el-breadcrumb-item>
    <el-breadcrumb-item>promotion management</el-breadcrumb-item>
    <el-breadcrumb-item>promotion list</el-breadcrumb-item>
    <el-breadcrumb-item>promotion detail</el-breadcrumb-item>
  </el-breadcrumb>
</template>

<style scoped lang="scss"></style>
```

#### 44 菜单折叠

当我们使用[vue3](https://so.csdn.net/so/search?q=vue3&spm=1001.2101.3001.7020)的setup模式时，我们该如何给组件命名呢？之前想过重新开一个script就行

```vue
<script>
export default {
    name: 'xxx'
}
</script>
 
<script setup>
// ...
</script>
```

但是这样确实让人感觉麻烦，当仔细阅读官方文档就会发现，官方其实提供了defineOptions函数，来实现一些声明式组件的内容,那么我们就能采用以下方式来定义组件名称

```vue
<script setup>
    defineOptions({
        name: 'xxx'
    })
</script>
```

**首先给layout下所有组件命名**，当组件调用自身时自己需要一个名字

如何实现菜单折叠效果呢？可以在仓库中定义一个变量，所有组件根据变量的值而变换

*store/modules/setting.ts*

```ts
//小仓库：layout组件相关配置仓库
import { defineStore } from 'pinia'
import { ref } from 'vue'

const useLayOutSettingStore = defineStore('SettingStore', () => {
  const fold = ref(false)
  return {
    fold,
  }
})
export default useLayOutSettingStore
```

默认是不折叠，即fold=false

首先解决点击tabbar最左侧图标点击变换问题,利用全局组件component和is属性实现，获取仓库中fold值，点击图标更改fold值，并变换图标

```vue
<script setup lang="ts">
import useLayOutSettingStore from '@/store/modules/setting.ts'
defineOptions({
  name: 'BreadCrumb',
})
//定义一个响应式数据控制图标切换
let LayOutSettingStore = useLayOutSettingStore()
//点击图标的方法
const changeIcon = () => {
  LayOutSettingStore.fold = !LayOutSettingStore.fold
}
</script>

<template>
  <!--顶部左侧静态-->
  <el-icon style="margin-right: 10px" @click="changeIcon">
+    <component :is="LayOutSettingStore.fold ? 'Fold' : 'Expand'"></component>
  </el-icon>
  <!--左侧面包屑-->
  ......
</template>
```

接下来是menu header main三块区域因为折叠与否而变换大小，给其绑定类fold，当其值为真时，启用flod样式

**注意el-menu有一个collapse属性，可以控制菜单项是否折叠，同样绑定仓库中fold值**

*layout/index.vue*

```html
<!--左侧菜单-->
+<div class="layout_aside" :class="{ fold: layOutSettingStore.fold }">
    <Logo></Logo>
    <el-scrollbar class="scrollbar">
        <!--滚动菜单组件 collapse用于折叠菜单-->
        <el-menu
                 :default-active="$route.path"
                 background-color="#001529"
                 text-color="white"
+                 :collapse="layOutSettingStore.fold"
                 >
            <!--根据路由动态生成菜单-->
            <Menu :menuList="userStore.menuRoutes"></Menu>
        </el-menu>
    </el-scrollbar>
</div>
<!--顶部导航-->
+<div class="layout_header" :class="{ fold: layOutSettingStore.fold }">
    <Tabbar></Tabbar>
</div>
<!--内容展示-->
+<div class="layout_main" :class="{ fold: layOutSettingStore.fold }">
    <Main></Main>
</div>
</div>
```

css

```css
.layout_container {
  ......
  .layout_aside {
    ......
+    transition: all 0.3s; //过渡动画
    .scrollbar {
      .....
    }
+    &.fold {
      width: $base_aside_min_width;
    }
  }
  .layout_header {
    ......
    transition: all 0.3s; //过渡动画
+    &.fold {
      width: calc(100vw - $base_aside_min_width);
      left: $base_aside_min_width; //当折叠后left也需要变
    }
  }
  .layout_main {
    ......
    transition: all 0.3s; //过渡动画
+    &.fold {
      width: calc(100vw - $base_aside_min_width);
      left: $base_aside_min_width; //当折叠后left也需要变
    }
  }
}
```

#### 45 顶部面包屑动态展示

首先要知道`$route.matched`会返回当前路径所有路由，比如/acl/user

```
/acl
/acl/user
```

所以我们可以根据此遍历该数组从而动态展示

*/layout/tabbar/breadcrumb*

```html
<!--左侧面包屑-->
  <el-breadcrumb separator-icon="ArrowRight">
    <!--面包屑动态展示路由名字和路由-->
    <el-breadcrumb-item
      v-for="item in $route.matched"
      :key="item.path"
      v-show="item.meta.title"
      :to="item.path"
    >
      <el-icon>
        <component :is="item.meta.icon"></component>
      </el-icon>
      <span style="vertical-align: top">{{ item.meta.title }}</span>
    </el-breadcrumb-item>
  </el-breadcrumb>
```

**注意，当内联元素垂直不对齐时，考虑使用`style="vertical-align: top"`**

此外，加上跳转`to`，这是`el-breadcrumb-item`标签所带属性，这时会产生一个问题，当点击一级路由路径时，显示内容区为空，我们修改一下routes，**使得每一个一级路由重定向到它的第一个子路由。**

**记得首页那里置空，并用v-show判断如果title为空，就不展示该路径** ` v-show="item.meta.title"`

#### 46 刷新业务

在setting.ts即layout组件相关配置仓库中添加refresh变量作为标记是否刷新

给对应刷新按钮加上点击事件，当触发事件时改变仓库里refresh变量值

*/layout/tabbar/setting*

```html
<el-button
    size="small"
    icon="Refresh"
    circle
+    @click="updateRefresh"
  ></el-button>
```

```js
let layOutSettingStore = useLayOutSettingStore()
//刷新按钮点击函数
const updateRefresh = () => {
  layOutSettingStore.refresh = !layOutSettingStore.refresh
}
```

当改变后，所谓的刷新其实就是销毁重建main区的组件

此时我们需要**侦听仓库里的变量是否变化，然后用v-if控制组件的销毁重建**

此处注意`v-if`是每次都会重新构建，而v-show只构建一次

还需要注意，此处销毁后何时重建呢？**应该使用官方的函数nextick（）而不是使用计时器等，因为nextick会保证dom更新后再触发。**

*/layout/main*

```js
import useLayOutSettingStore from '@/store/modules/setting.ts'
import { ref, watch, nextTick } from 'vue'
defineOptions({
  // eslint-disable-next-line vue/no-reserved-component-names
  name: 'Main',
})
let layLayOutSettingStore = useLayOutSettingStore()
//控制当前组件是否销毁重建
let flag = ref(true)
//监听仓库内部数据是否发生变化
//若发生变化，用户就点击过对应按钮
watch(
  () => layLayOutSettingStore.refresh,
  () => {
    //点击刷新按钮：路由组件销毁重建
    flag.value = false
    nextTick(() => {
      flag.value = true
    })
  },
)
```

```html
<!-- 路由组件出口的位置 -->
  <router-view v-slot="{ Component }">
    <!-- 加上这段，可以实现动画效果 -->
    <transition name="fade">
      <!-- 渲染一级路由的子路由 即内容区 -->
+      <component :is="Component" v-if="flag" />
    </transition>
  </router-view>
```

#### 47 全屏业务

```
fullscreenElement是dom的一个属性，可以用来是判断当前是否全屏，全屏时为true
document.fullscreenElement

dom节点的方法requestFullscreen 实现全屏模式
document.documentElement.requestFullscreen()

退出全屏模式
document.exitFullscreen()
```

给全屏按钮绑定点击事件，使用上述原生dom方法实现全屏

```js
//全屏按钮点击函数
const fullScreen = () => {
  //fullscreenElement是dom的一个属性，可以用来是判断当前是否全屏，全屏时为true
  let full = document.fullscreenElement
  if (!full) {
    //dom节点的方法requestFullscreen 实现全屏模式
    document.documentElement.requestFullscreen()
  } else {
    //退出全屏模式
    document.exitFullscreen()
  }
}
```

```html
<el-button
  size="small"
  icon="FullScreen"
  circle
  @click="fullScreen"
></el-button>
```

#### 48 获取用户信息和token理解

当登录后，用户的token已经存储在仓库之中，当主页等页面需要用到用户信息时，应该直接去仓库中取，所以在登录后跳转到的*/views/home*中应该发起请求，将用户信息存储到仓库中。

*/views/home* 在组件挂载后存储用户信息

```js
//引入组合式api函数之生命周期函数
import { onMounted } from 'vue'
//获取用户小仓库
import useUserStore from '@/store/modules/user.ts'
let userStore = useUserStore()
onMounted(() => {
  userStore.userInfo()
})
```

此时用封装的axios来做，因为之前定义了请求拦截器，我们可以在其中判断，如果当前仓库有token，就在请求头中加上token，便于服务器确定唯一用户，从而返回对应信息。

*/utils/request*

```js
//请求拦截器
request.interceptors.request.use((config) => {
  //config是配置对象，headers属性为请求头，经常给服务器端携带公共参数
  //当请求时，获取仓库里的token，如果有请求头添加token字段
+  const userStore = useUserStore()
+  if (userStore.token) {
+    config.headers.token = userStore.token
+  }
  return config
})
```

*/store/modules/user.ts* 定义用户信息相关字段，定义获取用户信息相关方法

```ts
const useUserStore = defineStore('User', () => {
  ......
  //用户相关信息字段
  const username = ref('')
  const avatar = ref('')
  return {
    ........
+    async userInfo() {
      //获取用户信息，存储到仓库当中
      const res = await reqUserInfo()
      //如果获取成功
      if (res.code == 200) {
        username.value = res.data.checkUser.username
        avatar.value = res.data.checkUser.avatar
      }
    },
    menuRoutes,
    token,
+    username,
+    avatar,
  }
})
```

然后在需要用用户信息的地方使用即可

*/layout/tabbar/setting*

```html
  <img
+    :src="userStore.avatar"
    style="
      width: 24px;
      height: 24px;
      margin: 0px 10px;
      vertical-align: top;
      border-radius: 50%;
    "
  />
  <!--下拉菜单-->
  <el-dropdown trigger="hover">
    <span class="el-dropdown-link" style="vertical-align: middle">
+      {{ userStore.username }}
      <el-icon class="el-icon--right"><arrow-down /></el-icon>
    </span>
```

*/views/home*

```html
<h1>{{ userStore.username }}</h1>
```

### 部分功能完善

#### 49 退出登录业务

当退出时，应该销毁本次的token以及仓库中所存的用户信息，下次登录重新获取

*views/home*

```html
+ <el-dropdown-item icon="SwitchButton" @click="logout">
    退出登录
</el-dropdown-item>
```

```js
//退出登录函数
const logout = () => {
  //第一件事情，需要向服务器发请求，退出登录 暂时没有不写
  //第二件事情：仓库当中关于用户先关的数据清空
  userStore.logout()
  //第三件事：跳转到登录页面
  $router.push('/login')
}
```

*store/modules/user.ts*

```js
async logout() {
    //目前没有mock接口：退出登录接口（通知服务器）
    token.value = ''
    username.value = ''
    avatar.value = ''
    DEL_TOKEN()
},
```

*utils/token.ts*

```ts
export const DEL_TOKEN = () => {
  localStorage.removeItem('TOKEN')
}
```

**在完成了上述工作后，继续考虑一个问题，当点击退出登录后，在登录页面点击登录按钮也 应该可以直接返回退出之前的页面。**

需求来源举例：淘宝选商品，在未登录时看的商品页面，在登录后应该跳转回该商品页面而非首页

**给跳转添加query参数来解决**

*views/home*

```js
const logout = () => {
  //第一件事情，需要向服务器发请求，退出登录 暂时没有不写
  //第二件事情：仓库当中关于用户先关的数据清空
  userStore.logout()
  //第三件事：跳转到登录页面
+  $router.push({ path: '/login', query: { redirect: $route.path } })
}
```

*views/login* login时判断

```js
const login = async () => {
  ......
  useStore
    .userLogin(loginForm)
    .then(() => {
+      $router.push({ path: ($route.query.redirect as string) || '/' })
      .......
    })
	.......
}
```

#### 50 路由切换进度条

vue-router有全局前置守卫和全局后置守卫，当一个路由触发时，全局前置守卫会被调用，我们可以在其中开始进度条。

**在路由守卫中发送请求获取用户信息是为了后期根据用户信息中的路由权限点生成动态路由**

在src目录下新建permission.ts文件,**注意当暂不需要一个参数，但之后会用到，可以在参数前面加_，从而避免警告**

```ts
//路由鉴权 也就是项目中路由什么条件下可以访问 什么时候不能访问
import router from '@/router'
//引入进度条插件及样式
import nprogress from 'nprogress'
import 'nprogress/nprogress.css'
//全局守卫：项目当中任意路由切换都会触发的钩子
//全局前置守卫
router.beforeEach((_to, _from, next) => {
  // to:即将要访问的路由信息
  // from:代表从哪个路径跳转而来
  // next:是一个函数，表示放行，next()放行，next(path) 放行到指定路由
  nprogress.start()
  next()
})
//全局后置守卫
// eslint-disable-next-line @typescript-eslint/no-unused-vars
router.afterEach((_to, _from) => {
  // to:即将要访问的路由信息
  // from:代表从哪个路径跳转而来
  nprogress.done()
})
```

#### 51 路由鉴权

路由鉴权 也就是项目中路由什么条件下可以访问 什么时候不能访问

**第一个问题：任意路由切换实现进度条业务 ----nprogress**

安装进度条插件

` pnpm i nprogress`

使用

*permission.ts*

```ts
//引入进度条插件及样式
import nprogress from 'nprogress'
import 'nprogress/nprogress.css'
//全局守卫：项目当中任意路由切换都会触发的钩子
//全局前置守卫
router.beforeEach(async (to, from, next) => {
  // to:即将要访问的路由信息
  // from:代表从哪个路径跳转而来
  // next:是一个函数，表示放行，next()放行，next(path) 放行到指定路由
  nprogress.start()
  next()
})
//全局后置守卫
// eslint-disable-next-line @typescript-eslint/no-unused-vars
router.afterEach((to, _from) => {
  // to:即将要访问的路由信息
  // from:代表从哪个路径跳转而来
  nprogress.done()
})
```

第二个问题：路由鉴权
全部路由组件 ：登录|404|任意路由|首页|数据大屏|权限管理（三个子路由）|商品管理（4个子路由）

用户未登录 ：可以访问login 其余都不行
登陆成功：不可以访问login 其余都可以

```ts
//路由鉴权 也就是项目中路由什么条件下可以访问 什么时候不能访问
import router from '@/router'
//引入进度条插件及样式
import nprogress from 'nprogress'
import 'nprogress/nprogress.css'
//进度条加载时的小圆圈设置
nprogress.configure({ showSpinner: false })
//引入用户仓库，根据仓库中token是否有值来判断是否登录
//注意此处应该获取pinia，因为此文件并不在项目组件中
import useUserStore from '@/store/modules/user.ts'
import pinia from '@/store'
const userStore = useUserStore(pinia)

//从setting文件中获取title展示在浏览器栏
import setting from '@/setting.ts'

//全局守卫：项目当中任意路由切换都会触发的钩子
//全局前置守卫
router.beforeEach(async (to, from, next) => {
  // to:即将要访问的路由信息
  // from:代表从哪个路径跳转而来
  // next:是一个函数，表示放行，next()放行，next(path) 放行到指定路由
  nprogress.start()
  if (userStore.token) {
    //用户登录成功，不能访问login
    if (to.path == '/login') {
      next(from.path)
    } else {
      //登录成功，访问其余六个路由
      //因为刷新后其它组件无法获取用户信息，我们只在home.vue中挂载时获取
      //所以在此处判断是否有用户信息，如果有放行，若无，发请求获取后放行
      if (userStore.username) {
        next()
      } else {
        try {
          await userStore.userInfo()
          next()
        } catch (error) {
          //token过期或者token被修改，无法得到用户信息
          //退出登录（目前未发请求完成），清空数据，回到首页
          userStore.logout()
          next({ path: '/login', query: { redirect: to.path } })
        }
      }
    }
  } else {
    //用户未登录
    if (to.path == '/login') {
      next()
    } else {
      next({ path: '/login', query: { redirect: to.path } })
    }
  }
})
//全局后置守卫
// eslint-disable-next-line @typescript-eslint/no-unused-vars
router.afterEach((to, _from) => {
  // to:即将要访问的路由信息
  // from:代表从哪个路径跳转而来
  nprogress.done()
  document.title = setting.title + ' - ' + to.meta.title
})
```

几个小问题

* 进度条加载在最右侧有一个小圆圈，可以使用`nprogress.configure({ showSpinner: false })`去除
* 浏览器中title应该根据路由不同而变化，引入setting.ts，后用document.title更改`document.title = setting.title + ' - ' + to.meta.title`

在引入用户仓库，根据仓库中token是否有值来判断是否登录时候

```ts
import useUserStore from '@/store/modules/user.ts' 
import pinia from '@/store' 
const userStore = useUserStore(pinia) 
```

```ts
import useUserStore from '@/store/modules/user.ts' 
import pinia from '@/store' 
const userStore = useUserStore() 就会报错
```

为什么`useUserStore(pinia) `这样写就不会说"getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"? 

如果你已经在全局中实例化了`pinia`，并且希望在其他地方使用它来创建`userStore`，那么你需要在调用`useUserStore(pinia)`时传入`pinia`参数。如果你希望使用默认的`pinia`实例，那么你需要在调用`useUserStore()`之前先调用`app.use(pinia)`来实例化`pinia`。

*main.ts*

```ts
import pinia from './store'
import router from '@/router'
......
+//引入路由鉴权
+import '@/permission.ts'
app.mount('#app')
```

#### 52 真实接口替换

首先将几个环境设置的服务器地址以及更改

*.env.development*

```
# 变量必须以 VITE_ 为前缀才能暴露给外部读取
NODE_ENV = 'development'
VITE_APP_TITLE = '硅谷甄选运营平台'
VITE_APP_BASE_API = '/dev-api'
VITE_SERVE='http://sph-api.atguigu.cn'
```

*.env.production*

```
NODE_ENV = 'production'
VITE_APP_TITLE = '硅谷甄选运营平台'
VITE_APP_BASE_API = '/prod-api'
VITE_SERVE='http://sph-api.atguigu.cn'
```

*.env.test*

```
# 变量必须以 VITE_ 为前缀才能暴露给外部读取
NODE_ENV = 'test'
VITE_APP_TITLE = '硅谷甄选运营平台'
VITE_APP_BASE_API = '/test-api'
VITE_SERVE='http://sph-api.atguigu.cn'
```

因为服务器地址和前端项目地址不一样,所以要解决跨域问题

*vite.config.ts*

```ts
export default defineConfig(({command,mode})=>{
  //loadEnv(mode,process.cwd()):获取各种环境下对应参数
  //mode：生产环境/开发环境/测试环境
  //process.cwd():获取当前根目录
  const env=loadEnv(mode,process.cwd())
  ........
    //代理跨域
    server: {
      proxy: {
        [env.VITE_APP_BASE_API]: {
          //获取数据服务器地址的设置
          target: env.VITE_SERVE,
          //是否需要代理跨域
          changeOrigin: true,
          //路径重写，因为服务器地址没有/dev-api，替换为空串
          rewrite: (path) => path.replace(/^\/dev-api/, ''),
        },
      },
    },
  }
})
```

现在登录成功/失败是返回如下字段,与原先的数据不相同了，所以要更改原先代码

```json
{
    "code": 200,
    "message": "成功",
    "data": "?????",
    "ok": true
}
{
    "code":201,
    "message":"失败",
    "data":"密码错误",
    "ok":false
}
```

退出登录成功返回

```json
{
    "code": 200,
    "message": "成功",
    "data": null,
    "ok": true
}
```

**更改*store/modules/user.ts***

```ts
const useUserStore = defineStore('User', () => {
  .......
  return {
    async userLogin(data: any) {
      ........
      if (result.code === 200) {
        //pinia仓库存储token
+        token.value = result.data as string
        ........
        return 'ok'
      } else {
        //这个会显示在promise.result中
+        return Promise.reject(new Error(result.data))
      }
    },
    async userInfo() {
      //获取用户信息，存储到仓库当中
      const res = await reqUserInfo()
      //如果获取成功
      if (res.code == 200) {
+        username.value = res.data.name
+        avatar.value = res.data.avatar
        return 'ok'
      } else {
+        return Promise.reject(new Error(res.message))
      }
    },
    async logout() {
      //退出登录接口（通知服务器）
+      const res = await reqLogout()
+      if (res.code == 200) {
+        token.value = ''
+        username.value = ''
+        avatar.value = ''
+        DEL_TOKEN()
+        return 'ok'
+      } else {
+        return Promise.reject(new Error(res.message))
      }
    },
    .......
  }
})
```

*/api/user/index.ts*

```ts
enum API {
  LOGIN_URL = '/admin/acl/index/login',
  USERINFO_URL = '/admin/acl/index/info',
  LOGOUT_URL = '/admin/acl/index/logout',
}

//登录接口
export const reqLogin = (data: any) =>
  //any限制data，loginResponseData限制后端返回类型
  request.post<any, any>(API.LOGIN_URL, data)

//获取用户信息接口
export const reqUserInfo = () => request.get<any, any>(API.USERINFO_URL)

//退出登录接口
export const reqLogout = () => request.post<any, any>(API.LOGOUT_URL)
```

*permission.ts*

```ts
//全局前置守卫
router.beforeEach(async (to, from, next) => {
  .........
        } catch (error) {
          //token过期或者token被修改，无法得到用户信息
          //退出登录（目前未发请求完成），清空数据，回到首页
+          await userStore.logout()
          next({ path: '/login', query: { redirect: to.path } })
        }
      }
    }
  } else {
    ......
  }
})
```

*layout/tabbar/setting/index.vue*

```js
//退出登录函数
const logout = async () => {
  //第一件事情，需要向服务器发请求，等待是否退出登录成功
+  await userStore.logout()
  //第二件事情：仓库当中关于用户先关的数据清空
  //第三件事：跳转到登录页面
  $router.push({ path: '/login', query: { redirect: $route.path } })
}
```

#### 53 接口ts类型定义

```ts
//暂时没有用，只是copy了，先不写
//登录接口需要携带参数类型
export interface loginFormData {
  username: string
  password: string
}

//定义全部接口返回数据都有的数据类型
export interface ResponseData {
  code: number
  message: string
  ok: boolean
}
//定义登录接口返回数据类型
export interface loginResponseData extends ResponseData {
  data: string
}

//定义获取用户信息返回的数据类型
export interface userInfoResponseData extends ResponseData {
  data: {
    routes: string[]
    button: string[]
    roles: string[]
    name: string
    avatar: string
  }
}

```

### 商品管理

main区使用card组件

#### 品牌管理

##### 54 静态页面

*views/product/trademark/index.vue*

```vue
<script setup lang="ts">
import { ref } from 'vue'
//当前页面
let currentPage = ref<number>(4)
//每页展示数据个数
let pageSize = ref<number>(3)

const addBrand = () => {
  alert('添加品牌')
}
</script>

<template>
  <el-card class="box-card">
    <!--卡片顶部添加按钮-->
    <el-button type="primary" size="default" icon="Plus" @click="addBrand">
      添加品牌
    </el-button>
    <!--卡片中间表格组件，用于展示已有品牌-->
    <!--
      table
      ---border:是否有纵向的边框
      table-column
      ---lable：某一列标题
      ---width：设置列的宽度
      ---align：设置列对齐方式
	  ---type：selection：多选框 index 该行的索引（从 1 开始计算） expand 显示一个可展开的按钮
     -->
    <el-table style="margin: 10px 0" border>
      <el-table-column label="序号" width="100px" align="center" />
      <el-table-column label="品牌名称" align="center" />
      <el-table-column label="品牌Logo" align="center" />
      <el-table-column label="品牌操作" align="center" />
    </el-table>
    <!--卡片底部 分页器-->
    <!--
      pagination
      ---v-model:current-page：设置当前分页器页码
      ---v-model:page-size:设置每一也展示数据条数
      ---page-sizes：每页显示个数选择器的选项设置
      ---:small="" ：值为布尔值，表示分页器大小，默认为false，大
      ---:disabled ：值为布尔值，是否禁用分页
      ---background:是否为分页按钮添加背景色
      ---layout：分页器6个子组件布局的调整 "->"把后面的子组件顶到右侧
      ---total：一共多少
     -->
    <el-pagination
      v-model:current-page="currentPage"
      v-model:page-size="pageSize"
      :page-sizes="[3, 5, 7, 9]"
      :small="false"
      :disabled="false"
      :background="true"
      layout="prev, pager, next, jumper,->, sizes, total"
      :total="400"
    />
  </el-card>
</template>

<style scoped lang="scss"></style>
```

##### 55 品牌管理页面数据展示

首先定义好相应api接口

*api/product/trademark/index.ts*

```ts
//品牌管理模块接口
import request from '@/utils/request.ts'
//品牌管理模块接口地址
enum API {
  //获取已有品牌接口
  TRADEMARK_URL = '/admin/product/baseTrademark',
}
//获取已有品牌的皆苦方法
//page:获取第几页 ---默认第一页
//limit:每一页展示多少条数据---默认三条
//page: number = 1：传入默认参数 es6语法
export const reqTradeMarkList = (page: number = 1, limit: number = 3) => {
  return request.get<any, any>(API.TRADEMARK_URL + `/${page}/${limit}`)
}
```

更改静态页面，使其动态展示

```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue'
//获取品牌数据接口函数
import { reqTradeMarkList } from '@/api/product/trademark'
//当前页面
let currentPage = ref<number>(1)
//每页展示数据个数
let pageSize = ref<number>(3)
//品牌数据总数
+let total = ref<number>(0)
//品牌数据数组
+let tradeMarkArr = ref<any[]>([])
+const getTradeMarkList = async () => {
  const res = await reqTradeMarkList(currentPage.value, pageSize.value)
  if (res.code == 200) {
    total.value = res.data.total
    tradeMarkArr.value = res.data.records
  }
}
//组件挂载完毕时，发一次请求获取品牌数据
+onMounted(() => {
  getTradeMarkList()
})

const addBrand = () => {
  alert('添加品牌')
}
</script>

<template>
  <el-card class="box-card">
    <!--卡片顶部添加按钮-->
    ........
    <!--卡片中间表格组件，用于展示已有品牌-->
    <!--
      table
      ---border:是否有纵向的边框
      table-column
      ---lable：某一列标题
      ---width：设置列的宽度
      ---align：设置列对齐方式
+      ---type：selection：多选框 index 该行的索引（从 1 开始计算） expand 显示为一个可展开的按钮
     -->
    <el-table style="margin: 10px 0" border :data="tradeMarkArr">
+      <el-table-column label="序号" type="index" width="100px" align="center" />
+      <el-table-column label="品牌名称" align="center">
        <!--
          除了直接<el-table-column label="品牌名称" prop="tmName" align="center"/>
          还可以使用作用域插槽
          <template v-slot="{ row, column, $index }">
             <span>{{ row.tmName }}</span>
          </template>
          row为数组数据
          column为列属性
          $index为索引
        -->
        <template v-slot="{ row }">
          <span>{{ row.tmName }}</span>
        </template>
      </el-table-column>
      <el-table-column label="品牌Logo" align="center">
        <template v-slot="{ row }">
          <img :src="row.logoUrl" style="width: 150px; height: 150px" />
        </template>
      </el-table-column>
      <el-table-column label="品牌操作" align="center">
        <template v-slot="{}">
          <el-button type="warning" size="small" icon="Edit">编辑</el-button>
          <el-button type="danger" size="small" icon="Delete">删除</el-button>
        </template>
      </el-table-column>
    </el-table>
    <!--卡片底部 分页器-->
    .........
  </el-card>
</template>

<style scoped lang="scss"></style>

```

##### 56 已有品牌类型

*api\product\trademark\type.ts*

```ts
export interface ResponseData {
  code: number
  message: string
  ok: boolean
}

//已有的品牌的ts数据类型
//这里id在新增的时候是不需要的，数据库自动加一，所以为可选字段
export interface TradeMark {
  id?: number
  tmName: string
  logoUrl: string
}

//包含全部品牌数据的ts类型
export type Records = TradeMark[]

//获取的已有全部品牌的数据ts类型
export interface TradeMarkResponseData extends ResponseData {
  data: {
    records: Records
    total: number
    size: number
    current: number
    searchCount: boolean
    pages: number
  }
}
```

*views/product/trademark/index.vue*

```js
......
//引入ts类型
import type {
  Records,
  TradeMarkResponseData,
} from '@/api/product/trademark/type'
.....
//品牌数据数组
+let tradeMarkArr = reactive<Records>([])
const getTradeMarkList = async () => {
+  const res: TradeMarkResponseData = await reqTradeMarkList(
   ........
}
```

*api/product/trademark/index.ts*

```ts
import request from '@/utils/request.ts'
import type { TradeMarkResponseData } from './type'
......
export const reqTradeMarkList = (page: number = 1, limit: number = 3) => {
+  return request.get<any, TradeMarkResponseData>(
    API.TRADEMARK_URL + `/${page}/${limit}`,
  )
}

```

##### 57 分页器点击事件

当点击页码时，应该发起请求，获取当前页的数据，同样当更改每页最大显示数据个数时也应该发起请求，重新获取数据

element-plus建议不使用标签上的事件，这里我们采用watch侦听器去侦听数据变化

```js
import { ref, reactive, onMounted, watch } from 'vue'
........
//品牌数据数组
+let tradeMarkArr = reactive<Records>([])
const getTradeMarkList = async () => {
  const res: TradeMarkResponseData = await reqTradeMarkList(
    currentPage.value,
    pageSize.value,
  )
  if (res.code == 200) {
    total.value = res.data.total
+    tradeMarkArr.splice(0, tradeMarkArr.length, ...res.data.records)
  }
}
......
//当前页码发生变化事件
//组件pagination回传了数据（当前页码）
watch(currentPage, () => {
  getTradeMarkList()
})
//页面size变化时
//组件pagination回传了数据（页大小）
watch(pageSize, () => {
  getTradeMarkList()
})
```

这里注意一下，视频中所写的是

```js
tradeMarkArr.value = res.data.records
```

但这时候，当发起请求时，table中的数据并不会实时更新，以下是codeium的回答

```
当您将tradeMarkArr = res.data.records赋值给tradeMarkArr时，实际上是将tradeMarkArr指向了一个新的数组对象。这意味着模板中绑定的tradeMarkArr仍然指向旧的数组对象，因此不会触发重新渲染。

而使用splice方法，它会在原地更新数组对象。通过调用splice方法，我们可以清空原始数组，并将res.data.records数组中的元素添加到tradeMarkArr中。这样，tradeMarkArr仍然指向同一个数组对象，但是数组的内容已经更改。由于Vue会跟踪对象的属性更改，因此当数组内容更改时，会自动触发模板重新渲染，从而更新绑定的值。

通过使用tradeMarkArr.splice(0, tradeMarkArr.length, ...res.data.records)，您可以确保tradeMarkArr数组的内容被正确地更新到模板中。
```

##### 58 对话框dialog静态搭建

综合运用dialog/form组件,样式为element-plus复制

*/views/product/trademark/index.vue*

```vue
<script setup lang="ts">
.........
//控制对话框显示与隐藏
let dialogFormVisible = ref<boolean>(false)
//添加品牌
const addBrand = () => {
  dialogFormVisible.value = true
}
//修改品牌
const updateBrand = () => {
  dialogFormVisible.value = true
}
//删除品牌
const deleteBrand = () => {
  dialogFormVisible.value = true
}
//对话框底部按钮取消和确定
const cancelDialog = () => {
  dialogFormVisible.value = false
}
const confirmDialog = () => {
  dialogFormVisible.value = false
}
</script>

<template>
  <el-card class="box-card">
    <!--卡片顶部添加按钮-->
+    <el-button type="primary" size="default" icon="Plus" @click="addBrand">
      添加品牌
    </el-button>
    ............
  <!--对话框组件-->
  <!--
    v-model：对话框显示/隐藏
    title：对话框标题
  -->
  <el-dialog v-model="dialogFormVisible" title="添加品牌">
    <el-form style="width: 80%">
      <el-form-item label="品牌名称" label-width="80px">
        <el-input placeholder="请您输入品牌名称"></el-input>
      </el-form-item>
      <el-form-item label="品牌LOGO" label-width="80px">
        <el-upload
          class="avatar-uploader"
          action="https://run.mocky.io/v3/9d059bf9-4660-45f2-925d-ce80ad6c4d15"
          :show-file-list="false"
          :on-success="handleAvatarSuccess"
          :before-upload="beforeAvatarUpload"
        >
          <img v-if="imageUrl" :src="imageUrl" class="avatar" />
          <el-icon v-else class="avatar-uploader-icon"><Plus /></el-icon>
        </el-upload>
      </el-form-item>
    </el-form>
    <!--具名插槽 footer-->
    <template #footer>
      <span class="dialog-footer">
        <el-button @click="cancelDialog">取消</el-button>
        <el-button type="primary" @click="confirmDialog">确定</el-button>
      </span>
    </template>
  </el-dialog>
</template>

<style scoped>
.avatar-uploader .avatar {
  width: 178px;
  height: 178px;
  display: block;
}
</style>

<style>
.avatar-uploader .el-upload {
  border: 1px dashed var(--el-border-color);
  border-radius: 6px;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  transition: var(--el-transition-duration-fast);
}

.avatar-uploader .el-upload:hover {
  border-color: var(--el-color-primary);
}

.el-icon.avatar-uploader-icon {
  font-size: 28px;
  color: #8c939d;
  width: 178px;
  height: 178px;
  text-align: center;
}
</style>
```

##### 59 新增品牌数据

###### api

**首先定义接口api**,可以看到修改和新增返回一样，实际上新增不需要id因为数据库自增，而修改需要id，可以将两个方法合二为一

```json
//修改
{
    "code": 200,
    "message": "成功",
    "data": null,
    "ok": true
}
//新增
{
    "code": 200,
    "message": "成功",
    "data": null,
    "ok": true
}
//上传图片
{
    "code": 200,
    "message": "成功",
    "data": "返回图片在服务器上",
    "ok": true
}
```

*api/product/trademark/index.ts*

```ts
//品牌管理模块接口
.......
import type { TradeMarkResponseData, TradeMark } from './type'
//品牌管理模块接口地址
enum API {
  ........
  //添加品牌接口
  ADDTRADEMARK_URL = '/admin/product/baseTrademark/save',
  //修改品牌接口
  UPDATETRADEMARK_URL = '/admin/product/baseTrademark/update',
}
.........
//添加与修改已有品牌接口方法
export const reqAddOrUpdateTradeMark = (tradeMark: TradeMark) => {
  //若有id则是修改，没有id则是添加
  if (tradeMark.id) {
    return request.put<any, any>(API.UPDATETRADEMARK_URL, tradeMark)
  } else {
    return request.post<any, any>(API.ADDTRADEMARK_URL, tradeMark)
  }
}
```

###### 收集品牌数据

注意 upload组件有一个action属性，它代表上传图片请求地址 注意/admin/product/fileUpload这样不行，因为代理服务器没有/api不转发，考虑到生产环境的正确运行，此处绑定一个actionUrl

```vue
<script setup lang="ts">
.........
//引入ts类型
import type {
  Records,
  TradeMarkResponseData,
  TradeMark,
} from '@/api/product/trademark/type'
import type { UploadProps } from 'element-plus'
import { ElMessage } from 'element-plus'
........
//定义收集新增品牌数据 
let tradeMarkForm = reactive<TradeMark>({
  id:0,
  tmName: '',
  logoUrl: '',
})
let actionUrl = ref<string>(
  import.meta.env.VITE_APP_BASE_API + '/admin/product/fileUpload',
)
........
//上传图片组件-》回调函数 上传之前约束文件类型，若判定不通过不会上传
const beforeAvatarUpload: UploadProps['beforeUpload'] = (rawFile) => {
  //可以构建数组，使用includes方法查找是否符合type
  const types = ['image/jpeg', 'image/gif', 'image/png']
  if (!types.includes(rawFile.type)) {
    ElMessage({
      message: '文件必须为 jpg|gif|png 格式!',
      type: 'error',
      duration: 2000,
    })
    return false
  } else if (rawFile.size / 1024 / 1024 > 2) {
    ElMessage({
      message: '文件大小不能大于 2MB!',
      type: 'error',
      duration: 2000,
    })
    return false
  }
  return true
}
//上传图片组件-》回调函数 上传成功后触发 参数如下
//(response: any, uploadFile: UploadFile, uploadFiles: UploadFiles) => void
//response：上传成功后返回的数据
const handleAvatarSuccess: UploadProps['onSuccess'] = (response) => {
  ElMessage({
    message: `上传图片${response.message}`,
    type: 'success',
    duration: 1000,
  })
  tradeMarkForm.logoUrl = response.data
  showFileList.value = true
}
</script>

<template>
  <el-card class="box-card">
    .........
  <!--对话框组件-->
  <!--
    v-model：对话框显示/隐藏
    title：对话框标题
  -->
  <el-dialog v-model="dialogFormVisible" title="添加品牌">
    <el-form style="width: 80%">
      <el-form-item
        label="品牌名称"
        label-width="80px"
        v-model="tradeMarkForm.tmName"
      >
        <el-input placeholder="请您输入品牌名称"></el-input>
      </el-form-item>
      <el-form-item label="品牌LOGO" label-width="80px">
        <!--
           upload组件
           action：上传图片请求地址 注意/admin/product/fileUpload这样不行，因为代理服务器没有/api不转发
                  考虑到生产环境的正确运行，此处绑定一个actionUrl
           show-file-list：是否显示已上传的文件列表，默认为 true
           on-success：上传成功的回调
           before-upload：上传前的回调，可以用来限制上传 参数为上传的文件
        -->
        <el-upload
          class="avatar-uploader"
          :action="actionUrl"
          :show-file-list="showFileList"
          :on-success="handleAvatarSuccess"
          :before-upload="beforeAvatarUpload"
        >
          <img
            v-if="tradeMarkForm.logoUrl"
            :src="tradeMarkForm.logoUrl"
            class="avatar"
          />
          <el-icon v-else class="avatar-uploader-icon"><Plus /></el-icon>
        </el-upload>
      </el-form-item>
    </el-form>
    <!--具名插槽 footer-->
    ........
  </el-dialog>
</template>
```

###### 完成添加

点击确定按钮回调

```js
const confirmDialog = async () => {
  let res = await reqAddOrUpdateTradeMark(tradeMarkForm)
  if (res.code == 200) {
    ElMessage({
      message: '添加品牌成功',
      type: 'success',
      duration: 1000,
    })
    //再次发请求获取所有数据 因为添加了一条
    getTradeMarkList()
  } else {
    ElMessage({
      message: '添加品牌失败',
      type: 'error',
      duration: 1000,
    })
  }
  dialogFormVisible.value = false
}
```

每次点击添加品牌的时候先清空之前的数据，并且不显示文件列表

```js
const addBrand = () => {
  dialogFormVisible.value = true
  //每一次添加时，收集的数据应该清空
  tradeMarkForm.tmName = ''
  tradeMarkForm.logoUrl = ''
  showFileList.value = false
}
```

##### 61 修改品牌数据

绑定点击函数,row为当前点击品牌数据

```html
<el-table-column label="品牌操作" align="center">
        <template v-slot="{ row }">
          <el-button
            type="warning"
            size="small"
            icon="Edit"
+            @click="updateBrand(row)"
          >
```

```js
//修改品牌 row即为当前点击品牌的数据
const updateBrand = (row: TradeMark) => {
  dialogFormVisible.value = true
  tradeMarkForm.id = row.id
  tradeMarkForm.tmName = row.tmName
  tradeMarkForm.logoUrl = row.logoUrl
}
```

**注意一个问题**：发送完请求后应该清除id，否则当修改后再添加，实际上只是对上一次修改对象的再一次修改

```js
const confirmDialog = async () => {
  //发请求时会自动判断此时有无id
  let res = await reqAddOrUpdateTradeMark(tradeMarkForm)
  if (res.code == 200) {
    ElMessage({
      message: `${tradeMarkForm.id ? '修改' : '添加'}品牌成功`,
      ....
    })
    //再次发请求获取所有数据 因为添加了一条
    getTradeMarkList()
  } else {
    ElMessage({
      message: `${tradeMarkForm.id ? '修改' : '添加'}品牌失败`,
      .......
    })
  }
  //发送完请求后应该清除id，否则当修改后再添加，实际上只是对上一次修改对象的再一次修改
  tradeMarkForm.id = 0
  dialogFormVisible.value = false
}
```

根据是否有id，修改dialog的title

```html
  <el-dialog
    v-model="dialogFormVisible"
+    :title="tradeMarkForm.id ? '修改品牌' : '添加品牌'"
  >
```

##### 62 dialog表单校验

和登录时使用的技巧类似

首先在form表单上绑定

```html
<el-form
      style="width: 80%"
+      :model="tradeMarkForm"
+      :rules="rules"
+      ref="ruleTradeMarkForm"
    >
```

其次在form-item上绑定props

```html
<el-form-item label="品牌名称" label-width="100px" prop="tmName">
<el-form-item label="品牌LOGO" label-width="100px" prop="logoUrl">  
```

然后书写表单校验规则

```js
//表单校验
let ruleTradeMarkForm = ref()
const rules = {
  tmName: [
    {
      required: true,
      trrigger: 'change',
      validator: (_rule: any, value: string, callback: any) => {
        if (value.trim().length >= 2) {
          callback()
        } else {
          callback(new Error('品牌名称至少2位'))
        }
      },
    },
  ],
  logoUrl: [
    {
      required: true,
      validator: (_rule: any, value: string, callback: any) => {
        if (value) {
          callback(new Error('品牌图片不能为空'))
        } else {
          callback()
        }
      },
    },
  ],
}
```

**但注意，因为logourl实际上是一个上传框，所以无法对起进行校验**，即使设置了`trrigger: 'change',`

所以要显式的在确认的时候进行一次校验

```js
const confirmDialog = async () => {
  //发请求前对所有表单项进行校验 校验通过才提交请求
  await ruleTradeMarkForm.value.validate()
```

还有一个问题，校验信息什么时候清除？

1.当图片没有上传点击确认后会出来校验的提示信息，我们上传图片后校验信息应该消失

```js
const handleAvatarSuccess: UploadProps['onSuccess'] = (response) => {
  .......
  //图片上传成功后 展示上传文件的列表 清除校验信息
  showFileList.value = true
  ruleTradeMarkForm.value.clearValidate()
}
```

2.当我们未填写信息去点击确认按钮时，会弹出2个校验信息。当我们关闭后再打开，校验信息还在。因为，我们需要在添加品牌按钮时清除校验信息。但是因为点击添加品牌，表单还没有加载，所以我们需要换个写法。

```js
const addBrand = () => {
  dialogFormVisible.value = true
  //每一次添加时，收集的数据应该清空 且校验的结果清空
  tradeMarkForm.tmName = ''
  tradeMarkForm.logoUrl = ''
  showFileList.value = false
  //注意第一次点击时，还没有form，此时清除会报错
  //两种解决方法，
  // 1. ruleTradeMarkForm.value?.resetFields() ts来解决
  // 2. nextTick（） 当dom更新后再使用 vue来解决
  nextTick(() => {
    ruleTradeMarkForm.value?.clearValidate()
  })
}
```

```js
const updateBrand = (row: TradeMark) => {
  dialogFormVisible.value = true
  tradeMarkForm.id = row.id
  tradeMarkForm.tmName = row.tmName
  tradeMarkForm.logoUrl = row.logoUrl
  //每一次修改时，校验的结果清空
  nextTick(() => {
    ruleTradeMarkForm.value?.clearValidate()
  })
}
```

##### 63 删除品牌数据

###### api

```json
//删除
{
    "code": 200,
    "message": "成功",
    "data": null,
    "ok": true
}
```

*/api/product/trademark/index*

```ts
enum API {
  .......
  //删除品牌接口
  DELETE_URL = '/admin/product/baseTrademark/remove',
}

//删除已有品牌
export const reqDeleteTradeMark = (id: number) => {
  return request.delete<any, any>(API.DELETE_URL + `/${id}`)
}
```

将原有删除button替换为气泡框组件

```html
<!--气泡确认框组件-->
          <el-popconfirm
            :title="`确定要删除${row.tmName}吗`"
            width="250px"
            icon="Delete"
            icon-color="red"
            cancel-button-text="取消"
            confirm-button-text="确定"
            @confirm="deleteBrand(row)"
          >
            <template #reference>
              <el-button type="danger" size="small">删除</el-button>
            </template>
          </el-popconfirm>
```

修改删除函数

```js
//气泡确认框确认按钮回调
const deleteBrand = async (row: TradeMark) => {
  let res = await reqDeleteTradeMark(row.id)
  if (res.code == 200) {
    ElMessage({
      message: '删除品牌成功',
      type: 'success',
      duration: 1000,
    })
    //删除成功之后再次获取所有数据，注意如果当前页只有一个，删除后应该回到上一页
    //实际上element帮我们做了这件事，不用考虑
    getTradeMarkList()
  } else {
    ElMessage({
      message: '删除品牌失败',
      type: 'error',
      duration: 1000,
    })
  }
}
```

### 属性管理

![image-20240113124418208](https://raw.githubusercontent.com/balance-hy/typora/master/2023img/202401131244534.png)

一级分类 二级分类 三级分类

注意二级分类根据一级分类的id来，三级分类根据二级分类的id来

#### 64 属性管理静态搭建

因为上面的card组件为分类，在很多页面也会用到，所以抽离出来，成为全局组件

*components/category*

```vue
<script setup lang="ts"></script>

<template>
  <el-card>
    <el-form :inline="true">
      <el-form-item label="一级分类">
        <el-select>
          <el-option label="beijing" />
          <el-option label="shanghai" />
          <el-option label="guangzhou" />
        </el-select>
      </el-form-item>
      <el-form-item label="二级分类">
        <el-select>
          <el-option label="beijing" />
          <el-option label="shanghai" />
          <el-option label="guangzhou" />
        </el-select>
      </el-form-item>
      <el-form-item label="三级分类">
        <el-select>
          <el-option label="beijing" />
          <el-option label="shanghai" />
          <el-option label="guangzhou" />
        </el-select>
      </el-form-item>
    </el-form>
  </el-card>
</template>
```

*components/index.ts*

```ts
//引入项目中全部的全局组件
import SvgIcon from '@/components/SvgIcon/index.vue'
import Category from '@/components/Category/index.vue'
.......
//全局对象
const allGlobalComponent: any = { SvgIcon, Category }
......
```

然后搭建静态页面

*views/product/attr*

```vue
<script setup lang="ts"></script>

<template>
  <!--属性管理-->
  <div>
    <Category />
    <el-card style="margin: 10px 0">
      <el-button type="primary" size="default" icon="Plus">添加品牌</el-button>
      <el-table style="margin: 10px 0">
        <el-table-column
          label="序号"
          type="index"
          align="center"
          width="80px"
        ></el-table-column>
        <el-table-column
          label="属性名称"
          align="center"
          width="120px"
        ></el-table-column>
        <el-table-column label="属性值名称" align="center"></el-table-column>
        <el-table-column
          label="操作"
          align="center"
          width="120px"
        ></el-table-column>
      </el-table>
    </el-card>
  </div>
</template>
```

#### 65 属性管理一级分类数据

> 一级分类的流程时：API->pinia->组件
>
> 为什么要使用pinia呢？因为在下面的添加属性那部分，父组件要用到三级分类组件的信息（id），涉及父子组件通信，所以放在仓库里方便一些。

##### api

*src\api\product\attr\index.ts*

```ts
// 属性相关api文件
import request from '@/utils/request.ts'
enum API {
  //获取一级分类接口地址
  C1_URL = '/admin/product/getCategory1',
  //获取二级分类接口地址 二级需要一级id
  C2_URL = '/admin/product/getCategory2',
  // 获取三级分类接口地址 三级需要一级id 二级id
  C3_URL = '/admin/product/getCategory3',
}
//一级分类接口方法
export const reqCategory1 = () => {
  return request.get<any, any>(API.C1_URL)
}
//二级分类接口方法
export const reqCategory2 = (Category1Id: number) => {
  return request.get<any, any>(API.C2_URL + `/${Category1Id}`)
}
//三级分类接口方法
export const reqCategory3 = (Category2Id: number) => {
  return request.get<any, any>(API.C3_URL + `/${Category2Id}`)
}

```

##### pinia

*src\store\modules\category.ts*

```ts
//商品分类全局组件的小仓库
import { defineStore } from 'pinia'
import { ref } from 'vue'
import { reqCategory1 } from '@/api/product/attr'

const useCategoryStore = defineStore('Category', () => {
  const Category1 = ref([])
  const c1Id = ref('')
  return {
    async getC1() {
      const res = await reqCategory1()
      if (res.code == 200) {
        Category1.value = res.data
      }
    },
    Category1,
    c1Id,
  }
})

export default useCategoryStore
```

##### Category组件

*src\components\Category\index.vue*

注意：**el-option**中的**:value**属性，它将绑定的值传递给**el-select**中的**v-model**绑定的值

```vue
<script setup lang="ts">
import { onMounted } from 'vue'
//引入分类仓库
import useCategoryStore from '@/store/modules/category.ts'
let categoryStore = useCategoryStore()
//组件挂载完毕，通知仓库发请求获取一级分类的数据
onMounted(() => {
  getC1()
})
//通知仓库获取一级分类的方法
const getC1 = () => {
  categoryStore.getC1()
}
</script>

<template>
  <el-card>
    <el-form :inline="true">
      <el-form-item label="一级分类">
        <el-select placeholder="请选择" v-model="categoryStore.c1Id">
          <!-- label:即为展示数据 value:即为select下拉菜单收集的数据 -->
          <el-option
            v-for="c1 in categoryStore.Category1"
            :key="c1.id"
            :label="c1.name"
            :value="c1.id"
          />
        </el-select>
      </el-form-item>
      <el-form-item label="二级分类">
        <el-select placeholder="请选择">
          <el-option label="beijing" />
          <el-option label="shanghai" />
          <el-option label="guangzhou" />
        </el-select>
      </el-form-item>
      <el-form-item label="三级分类">
        <el-select placeholder="请选择">
          <el-option label="beijing" />
          <el-option label="shanghai" />
          <el-option label="guangzhou" />
        </el-select>
      </el-form-item>
    </el-form>
  </el-card>
</template>
```

#### 66 分类数据ts类型

*src\api\product\attr\type.ts*

```ts
//分类相关的数据ts类型
export interface ResponseData {
  code: number
  message: string
  ok: boolean
}

//分类ts类型
export interface CategoryObj {
  id: number | string
  name: string
  category1Id?: number
  category2Id?: number
}

//相应的分类接口返回数据的类型
export interface CategoryResponseData extends ResponseData {
  data: CategoryObj[]
}
```

*src\store\modules\types\type.ts*

```ts
//定义分类仓库对象的ts类型
export interface CategoryState {
  c1Id: string | number
  Category1: CategoryObj[]
  Category2: CategoryObj[]
  c2Id: string | number
  Category3: CategoryObj[]
  c3Id: string | number
}
```

然后补全*src\api\product\attr\index*，*src\store\modules\category*中的类型即可

#### 67 完成分类组件

> 分类组件就是组件挂载拿到一级数据，通过用户选择后我们会拿到一级数据中对应id，通过此id发送请求之后二级分类就会拿到数据。以此类推

二级分类不是一上来就发生变化，而是要等一级分类确定好之后再发送请求获得数据。将这个发送请求的回调函数绑定在了一级分类的**change**属性上，同理三级分类是要等二级分类确定好之后再发送请求

还需要注意一下，当全部目录选择好了，再次选择一级分类，此时需要清空二级分类id、三级分类id、三级分类数据，再次选择二级分类，此时需要清空三级分类id

*src\components\Category\index.vue*

```vue
<script setup lang="ts">
........
//此方法即为一级分类下拉菜单的change事件(选中值的时候会触发,保证一级分类ID有了)
const handler = () => {
  //当选择一级分类的id时需要清除二级id，三级id，三级数据
  categoryStore.c2Id = ''
  categoryStore.c3Id = ''
  categoryStore.Category3 = []
  //通知仓库获取二级分类
  categoryStore.getC2()
}
//此方法即为二级分类下拉菜单的change事件
const handler2 = () => {
  //当选择二级分类的id时需要清除三级id
  categoryStore.c3Id = ''
  categoryStore.getC3()
}
const handler3 = () => {
  alert(123)
}
</script>

<template>
  <el-card>
    <el-form :inline="true">
      <el-form-item label="一级分类">
        <el-select
          placeholder="请选择"
          v-model="categoryStore.c1Id"
          @change="handler"
        >
          <!-- label:即为展示数据 value:即为select下拉菜单收集的数据 -->
+          <el-option
            v-for="c1 in categoryStore.Category1"
            :key="c1.id"
            :label="c1.name"
            :value="c1.id"
          />
        </el-select>
      </el-form-item>
      <el-form-item label="二级分类">
        <el-select
          placeholder="请选择"
+          v-model="categoryStore.c2Id"
+          @change="handler2"
        >
+          <el-option
            v-for="c2 in categoryStore.Category2"
            :key="c2.id"
            :label="c2.name"
            :value="c2.id"
          />
        </el-select>
      </el-form-item>
      <el-form-item label="三级分类">
        <el-select
          placeholder="请选择"
+          v-model="categoryStore.c3Id"
+          @change="handler3"
        >
+          <el-option
            v-for="c3 in categoryStore.Category3"
            :key="c3.id"
            :label="c3.name"
            :value="c3.id"
          />
        </el-select>
      </el-form-item>
    </el-form>
  </el-card>
</template>
```

*src\store\modules\category.ts*,新增仓库数据

```ts
//商品分类全局组件的小仓库
import { defineStore } from 'pinia'
import { ref } from 'vue'
import { reqCategory1, reqCategory2, reqCategory3 } from '@/api/product/attr'
import { CategoryResponseData } from '@/api/product/attr/type.ts'
import { CategoryState } from '@/store/modules/types/type.ts'

const useCategoryStore = defineStore('Category', () => {
  const Category1 = ref<CategoryState['Category1']>([])
  const Category2 = ref<CategoryState['Category2']>([])
  const Category3 = ref<CategoryState['Category3']>([])
  const c1Id = ref<CategoryState['c1Id']>('')
  const c2Id = ref<CategoryState['c2Id']>('')
  const c3Id = ref<CategoryState['c3Id']>('')
  return {
    async getC1() {
      const res: CategoryResponseData = await reqCategory1()
      if (res.code == 200) {
        Category1.value = res.data
      }
    },
    async getC2() {
      const res: CategoryResponseData = await reqCategory2(c1Id.value)
      if (res.code == 200) {
        Category2.value = res.data
      }
    },
    async getC3() {
      const res: CategoryResponseData = await reqCategory3(c2Id.value)
      if (res.code == 200) {
        Category3.value = res.data
      }
    },
    Category1,
    Category2,
    Category3,
    c1Id,
    c2Id,
    c3Id,
  }
})

export default useCategoryStore
```

还有一个小问题，**当分类目录未全部选择时，新增按钮应该为禁用状态,表格应该不显示**

*views/product/attr*

```vue
<script setup lang="ts">
//获取分类数据仓库
+ import useCategoryStore from '@/store/modules/category.ts'
+ let categoryStore = useCategoryStore()
</script>

<template>
  <!--属性管理-->
  <div>
    <Category />
    <el-card style="margin: 10px 0">
      <el-button
        type="primary"
        size="default"
        icon="Plus"
+        :disabled="!categoryStore.c3Id"
      >
        添加品牌
      </el-button>
+      <el-table style="margin: 10px 0" border v-show="categoryStore.c3Id">
        ..........
      </el-table>
    </el-card>
  </div>
</template>
```

#### 68 已有属性展示业务

返回的数据格式

```json
{
  "code": 200,
  "message": "成功",
  "data": [
    {
      "id": 24927,
      "createTime": null,
      "updateTime": null,
      "attrName": "111",
      "categoryId": 61,
      "categoryLevel": 3,
      "attrValueList": [
        {
          "id": 189444,
          "createTime": null,
          "updateTime": null,
          "valueName": "222",
          "attrId": 24927
        }
      ]
    },
  ],
  "ok": true
}
```

##### api

*/api/product/attr/index*

```ts
// 属性相关api文件
.......
import type { AttrResponseData } from '@/api/product/attr/type.ts'
enum API {
  .......
  //获取分类下已有的属性与属性值
  ATTR_URL = '/admin/product/attrInfoList',
}
........
//获取分类下已有的属性与属性值
export const reqAttrInfoList = (
  category1Id: number | string,
  category2Id: number | string,
  category3Id: number | string,
) => {
  return request.get<any, AttrResponseData>(
    API.ATTR_URL + `/${category1Id}/${category2Id}/${category3Id}`,
  )
}
```

*/api/product/attr/type*

```ts
.......

//属性值对象的ts类型
export interface AttrValue {
  id?: number
  valueName: string
  attrId?: number
  flag?: boolean
}
//存储每一个属性值的数组类型
export type AttrValueList = AttrValue[]
//属性对象
export interface Attr {
  id?: number
  attrName: string
  categoryId: number | string
  categoryLevel: number
  attrValueList: AttrValueList
}
//存储每一个属性对象的数组ts类型
export type AttrList = Attr[]
//属性接口返回的数据ts类型
export interface AttrResponseData extends ResponseData {
  data: Attr[]
}
```

##### 组件获取返回数据并存储数据

*/views/product/attr/index.vue*

注意：通过watch监听c3Id，来适时的获取数据。

```vue
<script setup lang="ts">
//获取分类数据仓库
import useCategoryStore from '@/store/modules/category.ts'
import { watch, ref } from 'vue'
import { reqAttrInfoList } from '@/api/product/attr'
import type { AttrResponseData, Attr } from '@/api/product/attr/type.ts'
let categoryStore = useCategoryStore()
//存储已用属性和属性值
let attrArr = ref<Attr[]>([])
//监听三级分类的变化，发送请求获取属性列表
watch(
  () => categoryStore.c3Id,
  async (newValue) => {
    //清空上一次查询的属性与属性值
    attrArr.value = []
    //如果不为空，就发请求，若为空，不发请求
    if (newValue) {
      let res: AttrResponseData = await reqAttrInfoList(
        categoryStore.c1Id,
        categoryStore.c2Id,
        categoryStore.c3Id,
      )
      if (res.code === 200) {
        attrArr.value = res.data
      }
    }
  },
)
</script>
```

##### 将数据放入模板中

```vue
<template>
  <!--属性管理-->
  <div>
    <Category />
    <el-card style="margin: 10px 0">
      ......
      <el-table
        .....
      >
        .....
        <el-table-column
          label="属性名称"
+          width="160px"
          prop="attrName"
        ></el-table-column>
        <el-table-column label="属性值名称">
+          <template v-slot="{ row }">
            <el-tag
              v-for="item in row.attrValueList"
              :key="item.id"
              style="margin: 5px"
            >
              {{ item.valueName }}
            </el-tag>
          </template>
        </el-table-column>
+        <el-table-column label="操作" width="160px">
+          <template v-slot="{ row }">
            <el-button type="warning" size="small" icon="Edit"></el-button>
            <el-button type="danger" size="small" icon="Delete"></el-button>
          </template>
        </el-table-column>
      </el-table>
      ......
    </el-card>
  </div>
</template>
```

#### 69 添加与修改静态搭建

考虑到添加属性会展示全新的card组件内容，在el-card内容外加上div，通过变量操纵其显示,加上对应点击事件

*/views/product/attr/index.vue*

```vue
<script setup lang="ts">
.......

//添加属性点击函数
const addAttr = () => {
  scene.value = 1
}
//修改属性点击函数
const updateAttr = () => {
  scene.value = 1
}
//保存添加/修改的属性
const saveAttr = () => {
  scene.value = 0
}
//取消将要添加的属性
const cancelAddAttr = () => {
  scene.value = 0
}
</script>

<template>
  <!--属性管理-->
  <div>
+    <Category :scene="scene" />
    <el-card style="margin: 10px 0">
      <div v-show="scene === 0">
        ........
      </div>
      <div v-show="scene === 1">
        <el-form :inline="true">
          <el-form-item label="属性名">
            <el-input placeholder="请输入属性名称"></el-input>
          </el-form-item>
        </el-form>
        <el-button type="primary" size="default" icon="Plus">
          添加属性
        </el-button>
        <el-button size="default">取消</el-button>
        <el-table border style="margin: 10px 0">
          <el-table-column
            label="序号"
            width="80px"
            type="index"
            align="center"
          ></el-table-column>
          <el-table-column label="属性值名称"></el-table-column>
          <el-table-column label="操作"></el-table-column>
        </el-table>
        <el-button type="primary" size="default" @click="saveAttr">
          保存
        </el-button>
        <el-button size="default" @click="cancelAddAttr">取消</el-button>
      </div>
      <img
        .....
      />
    </el-card>
  </div>
</template>
```

注意当切换时，分类选择下拉框应该禁用,在父组件attr向子组件category传入scene，用于判断是否禁用，为1时禁用

*src\components\Category\index.vue*

```vue
<script setup lang="ts">
......
defineProps(['scene'])
.......
</script>

<template>
  <el-card>
    <el-form :inline="true">
      <el-form-item label="一级分类">
        <el-select
          placeholder="请选择"
          v-model="categoryStore.c1Id"
          @change="handler"
+          :disabled="scene !== 0"
        >
          <!-- label:即为展示数据 value:即为select下拉菜单收集的数据 -->
          <el-option
            v-for="c1 in categoryStore.Category1"
            :key="c1.id"
            :label="c1.name"
            :value="c1.id"
          />
        </el-select>
      </el-form-item>
      <el-form-item label="二级分类">
        <el-select
          placeholder="请选择"
          v-model="categoryStore.c2Id"
          @change="handler2"
+         :disabled="scene !== 0"
        >
          <el-option
            v-for="c2 in categoryStore.Category2"
            :key="c2.id"
            :label="c2.name"
            :value="c2.id"
          />
        </el-select>
      </el-form-item>
      <el-form-item label="三级分类">
        <el-select
          placeholder="请选择"
          v-model="categoryStore.c3Id"
          @change="handler3"
+          :disabled="scene !== 0"
        >
          <el-option
            v-for="c3 in categoryStore.Category3"
            :key="c3.id"
            :label="c3.name"
            :value="c3.id"
          />
        </el-select>
      </el-form-item>
    </el-form>
  </el-card>
</template>
```

#### 70 属性接口参数理解

```json
//添加属性与属性已有的属性的参数解释
//修改携带参数
{
    "id":"",//已有的属性的ID
    "attrName":"",//已有的属性的名字
    "attrValueList":[
        {
            "attrId":'',//属性值归属于哪一个属性//已有的属性值的ID
    		"id":'',//属性值归属于哪一个属性
    		"valueName":"string",
        },
    ],
    "categoryId":"",//已有的属性归属于哪个三级分类
    "categoryLevel":3,//代表的是几级分类
}
//某一个三级分类添加一个新的属性
{
    "attrName":"string",//新增的属性的名字
	"attrValueList":[//新增的属性值数组
    	{
    	  "valueName":"string"
		}
	],
    categoryId:'',//三级分类的ID
    categoryLevel:3,
}
```

##### api

```ts
// 属性相关api文件
......
import type { AttrResponseData, Attr } from '@/api/product/attr/type.ts'
enum API {
  ........
  //添加或者修改属性
  ADDORUDATEATTR_URL = '/admin/product/saveAttrInfo',
}
........
//添加或者修改属性
export const reqAddOrUpdateAttr = (data: Attr) => {
  return request.post<any, any>(API.ADDORUDATEATTR_URL, data)
}
```

##### 新增属性数据存储

```vue
<script setup lang="ts">
//获取分类数据仓库
......
import type { AttrResponseData, Attr } from '@/api/product/attr/type.ts'
......
//收集新增的属性数据
let attrParam = reactive<Attr>({
  attrName: '', //新增的属性的名字
  attrValueList: [], //新增的属性值数组
  categoryId: '', //已有的属性归属于那个三级分类
  categoryLevel: 3, //代表的是几级分类
})
......
</script>
```

#### 71 添加新的属性

>添加属性值的总体思路是：收集表单的数据（绑定对应的表单项等）->发送请求（按钮回调函数，携带的参数）->更新页面

##### 收集表单的数据（attrParam）

此时注意，当未填写属性名称时，按钮（添加属性值，清空属性值，保存）应当禁用

```html
<div v-show="scene === 1">
        <el-form :inline="true">
          <el-form-item label="属性名">
            <el-input
              placeholder="请输入属性名称"
+              v-model="attrParam.attrName"
            ></el-input>
          </el-form-item>
        </el-form>
        <el-button
+          :disabled="!attrParam.attrName"
          type="primary"
          size="default"
          icon="Plus"
+          @click="addAttrValue"
        >
          添加属性值
        </el-button>
        <el-button
          size="default"
+          :disabled="!attrParam.attrName"
+          @click="cancelAllAttrValue"
        >
          清空属性值
        </el-button>
+        <el-table border style="margin: 10px 0" :data="attrParam.attrValueList">
          <el-table-column
            label="序号"
            width="80px"
            type="index"
            align="center"
          ></el-table-column>
          <el-table-column label="属性值名称">
+            <template v-slot="{ row }">
              <!--row即为属性值对象，即{ "valueName": "" }-->
              <el-input
                placeholder="请输入属性值"
                v-model="row.valueName"
              ></el-input>
            </template>
          </el-table-column>
          <el-table-column label="操作"></el-table-column>
        </el-table>
        <el-button
          type="primary"
          size="default"
          @click="saveAttr"
+          :disabled="!attrParam.attrName"
        >
          保存
        </el-button>
        .....
      </div>
```

##### 按钮点击函数/更新页面

每一次点击的时候,先清空一下数据再收集数据。防止下次点击时会显示上次的数据

```ts
//监听三级分类的变化，发送请求获取属性列表
watch(
  () => categoryStore.c3Id,
  (newValue) => {
    //清空上一次查询的属性与属性值
    attrArr.value = []
    //如果不为空，就发请求，若为空，不发请求
    if (newValue) {
+      getAttrList()
    }
  },
)
+ let getAttrList = async () => {
  let res: AttrResponseData = await reqAttrInfoList(
    categoryStore.c1Id,
    categoryStore.c2Id,
    categoryStore.c3Id,
  )
  if (res.code === 200) {
    attrArr.value = res.data
  }
}

//添加属性点击函数
const addAttr = () => {
  //每一次点击时清空数据
+  attrParam.attrName = ''
+  attrParam.attrValueList = []
  //确定添加的是哪一个三级分类
+  attrParam.categoryId = categoryStore.c3Id
  scene.value = 1
}
//修改属性点击函数
.....

//点击添加属性值
const addAttrValue = () => {
+  attrParam.attrValueList.push({ valueName: '' })
}
//取消添加的所有属性值
const cancelAllAttrValue = () => {
+  attrParam.attrValueList = []
}
//保存添加/修改的属性，发送请求
const saveAttr = async () => {
+  let res = await reqAddOrUpdateAttr(attrParam)
  //判断是否添加成功
+  if (res.code === 200) {
    //切换场景
    scene.value = 0
    ElMessage({
      type: 'success',
      message: attrParam.id ? '修改成功' : '添加成功',
    })
    //重新获取属性列表，更新页面
    getAttrList()
  } else {
    ElMessage({
      type: 'error',
      message: attrParam.id ? '修改失败' : '添加失败',
    })
  }
}
//取消将要添加的属性
.....
```

#### 72 属性值编辑模式与查看模式

考虑用v-if和v-else来进行切换，但这样就涉及到一个问题，如何设置变量切换呢，不能单独设置一个变量，因为每一个属性值都是独立的，考虑在点击添加属性值时，为每一个属性值添加flag

在input下面添加了一个div，使用flag来决定哪个展示。

```html
<el-table-column label="属性值名称">
            <template v-slot="{ row, $index }">
              <!--row即为属性值对象，即{ "valueName": "" }-->
              <el-input
+                v-if="row.flag"
                placeholder="请输入属性值"
                v-model="row.valueName"
+                @blur="toLook(row, $index)"
              ></el-input>
+              <div v-else @click="toEdit(row)">
                {{ row.valueName }}
              </div>
            </template>
          </el-table-column>
```

```js
//点击添加属性值
const addAttrValue = () => {
  attrParam.attrValueList.push({
    valueName: '',
    flag: true, //控制编辑模式和查看模式的切换
  })
}
```

在进行切换时，要考虑处理非法属性值

```ts
//添加属性输入框焦点失去
const toLook = (row: AttrValue, $index: number) => {
  //非法情况1：属性值为空
  if (row.valueName.trim() === '') {
    //删除属性值为空的行，即当前行
    attrParam.attrValueList.splice($index, 1)
    ElMessage({
      type: 'error',
      message: '属性值不能为空',
    })
    return
  }
  //非法情况2：属性值重复
  let isRepeat = attrParam.attrValueList.some((item) => {
    //除当前行外查找是否有重复
    if (item !== row) {
      return row.valueName === item.valueName
    }
  })
  if (isRepeat) {
    //删除属性值为空的行，即当前行
    attrParam.attrValueList.splice($index, 1)
    ElMessage({
      type: 'error',
      message: '属性值不能重复',
    })
    return
  }
  //模式切换为查看模式
  row.flag = false
}
//属性值div点击事件
const toEdit = (row: AttrValue) => {
  //相应的属性值对象flag:变为true,展示input
  row.flag = true
}
```

在点击保存提交按钮时，也要删除为空的属性值（点击添加属性值，再直接点击保存，也会有空串，前面的非法检查不会触发）

```js
//保存添加/修改的属性，发送请求
const saveAttr = async () => {
  //当点击保存时检查是否有 属性值为空，若有，删除
  attrParam.attrValueList = attrParam.attrValueList.filter(
    (item) => item.valueName.trim() !== '',
  )
  if (attrParam.attrValueList.length === 0) {
    ElMessage({
      type: 'error',
      message: '属性值不能为空',
    })
    return
  }
  ........
}
```

#### 73 表单聚焦和删除业务

> 当点击表单input框时，应该要直接聚焦（文字最后闪烁），input有focus方法，可以完成这一点。

完成上述需求需要获取到组件实例，有两种方案，即 ref(静态) 和 :ref(动态)

在Vue中，ref和:ref在模板的标签属性中有一些区别。

**ref**：ref是一个普通的HTML属性，用于在模板中给元素或组件添加一个标识。可以通过this.$refs来访问有ref属性的元素或组件的实例。例如：

```vue
<template>
  <div>
    <input ref="myInput" type="text">
  </div>
</template>
```

在上面的例子中，使用ref属性给input元素添加了一个标识myInput，在组件的JavaScript代码中可以通过this.$refs.myInput来访问这个input元素的实例。

**:ref**：ref是一个动态属性，用于在模板中给元素或组件添加一个动态的标识。可以通过在模板中使用Vue的数据绑定语法来动态设置ref属性的值。例如：

```vue
<template>
  <div>
    <input :ref="inputRef" type="text">
  </div>
</template>
```

在上面的例子中，inputRef是Vue组件的一个数据属性，可以根据需要进行动态设置。在组件的JavaScript代码中可以通过this.$refs[inputRef]来访问这个input元素的实例。

```js
//准备一个数组:将来存储对应的组件实例el-input
let inputArr = ref<any>([])
```

```html
<el-input
+   :ref="(vc: any) => (inputArr[$index] = vc)"
   v-if="row.flag"
   placeholder="请输入属性值"
   v-model="row.valueName"
   @blur="toLook(row, $index)"
></el-input>
<div v-else @click="toEdit(row)">
    {{ row.valueName }}
</div>
```

考虑两个地方的自动聚焦，一是点击输入框时自动聚焦，而是点击输入按钮时自动聚焦到新增的输入框上

注意这两处都需要使用nextTick函数，因为点击后，组件需要加载，没办法第一时间拿到组件实例。所以使用nextTick会等到组件加载完毕后才调用

```js
//点击添加属性值
const addAttrValue = () => {
  .....
  //自动聚焦到最后一个输入框
  nextTick(() => {
    inputArr.value[attrParam.attrValueList.length - 1].focus()
  })
}

//属性值div点击事件
const toEdit = (row: AttrValue, $index: number) => {
  //相应的属性值对象flag:变为true,展示input
  row.flag = true
  //获取input焦点
  nextTick(() => {
    inputArr.value[$index].focus()
  })
}
```

**此时可以删除72在保存按钮所写判断，因为聚焦的存在，当失去焦点就会判断，就不会出现未被检查的情况**

```js
const saveAttr = async () => {
-  ......  
  let res = await reqAddOrUpdateAttr(attrParam)
  //判断是否添加成功
  .....
}
```

至于删除，很简单，加上按钮,添加点击事件即可

```html
<el-table-column label="操作">
    <template v-slot="{ $index }">
        <el-button
                   type="danger"
                   size="small"
                   icon="Delete"
                   @click="attrParam.attrValueList.splice($index, 1)"
                   ></el-button>
    </template>
</el-table-column>
```

#### 74 修改属性

当修改属性时，可以将数据直接赋值给 attrParam ，但 Object.assign 只是浅拷贝，会出现问题，此时可以使用Json来进行深拷贝

```js
//修改属性点击函数
const updateAttr = (row: Attr) => {
  scene.value = 1
  //深拷贝，防止修改原来的数据，影响到row
  Object.assign(attrParam, JSON.parse(JSON.stringify(row)))
}
```

需要注意的是，**这种方法适用于对象中只包含基本数据类型和一层嵌套的情况**。对于包含函数、原型链、循环引用等复杂情况，更复杂的深拷贝方法(Lodash )可能是更安全和可靠的选择。

因为请求会根据是否携带id而判断是修改还是添加，但现在出现了新的问题，当修改后，attrParam 就有了

id，此时再点击添加，实际上却是修改，在点击添加时清除id（若有）

```js
//添加属性点击函数
const addAttr = () => {
  //每一次点击时清空数据
  ......
  //如果attrParam中有id，就删除id属性
  if (Object.hasOwnProperty.call(attrParam, 'id')) {
    delete attrParam.id
  }
  //确定添加的是哪一个三级分类
  ......
}
```

#### 75 删除属性业务

##### api

```ts
enum API {
  .......
  //删除属性
  DELETEATTR_URL = '/admin/product/deleteAttr',
}
//删除属性
export const reqDeleteAttr = (attrId: number | string) => {
  return request.delete<any, any>(API.DELETEATTR_URL + `/${attrId}`)
}
```

##### 气泡确认框删除

```html
<el-popconfirm
               :title="`确定删除属性 ${row.attrName} 吗?`"
               width="250px"
               icon="Delete"
               icon-color="red"
               cancel-button-text="取消"
               confirm-button-text="确定"
               @cancel="console.log(row)"
               @confirm="deleteAttr(row.id)"
               >
    <template #reference>
        <el-button
                   type="danger"
                   size="small"
                   icon="Delete"
         ></el-button>
    </template>
</el-popconfirm>
```

```js
//删除属性
const deleteAttr = async (id: number | string) => {
  let res = await reqDeleteAttr(id)
  if (res.code === 200) {
    ElMessage({
      type: 'success',
      message: '删除成功',
    })
    //重新获取属性列表，更新页面
    getAttrList()
  } else {
    ElMessage({
      type: 'error',
      message: '删除失败',
    })
  }
}
```

##### 路由跳转前清空数据

当点击其他页面，当前页面的数据应该清空，或者组件创建时发送请求获取数据，此处选择清空

**重置 state**

使用[选项式 API](https://pinia.vuejs.org/zh/core-concepts/#option-stores) 时，你可以通过调用 store 的 `$reset()` 方法将 state 重置为初始值。

```js
const store = useStore()

store.$reset()
```

在 `$reset()` 内部，会调用 `state()` 函数来创建一个新的状态对象，并用它替换当前状态。

在 [Setup Stores](https://pinia.vuejs.org/core-concepts/#setup-stores) 中，您需要创建自己的 `$reset()` 方法：

```js
export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)

  function $reset() {
    count.value = 0
  }

  return { count, $reset }
})
```

*/store/modules/category*

```ts
const useCategoryStore = defineStore('Category', () => {
  .......
  return {
    .......
    $reset() {
      c1Id.value = ''
      c2Id.value = ''
      c3Id.value = ''
      Category1.value = []
      Category2.value = []
      Category3.value = []
    },
    .....
  }
})
```

*/views/product/attr*

```js
//路由组件销毁的时候，把仓库分类相关的数据清空
onBeforeUnmount(() => {
  categoryStore.$reset()
})
```

### spu管理

> SPU(Standard Product Unit)：**标准化产品**单元。是商品**信息聚合**的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，**属性值**、特性相同的商品就可以称为一个SPU。
>
> 苹果手机的例子中，一个SPU可能是所有不同容量版本的苹果手机，而每个容量版本的手机都有各自的SKU，如256GB、512GB和1TB等

#### 77 spu模块静态搭建

```vue
<script setup lang="ts">
import { ref } from 'vue'  
//场景切换
let scene = ref<number>(0)
//分页器默认页码
let currentPage = ref<number>(1)
//每页展示数据个数
let pageSize = ref<number>(3)
//品牌数据总数
let total = ref<number>(0)
</script>

<template>
  <div>
    <Category :scene="scene" />
    <el-card style="margin: 10px 0">
      <div v-show="scene === 0">
        <el-button type="primary" @click="scene = 1" icon="Plus">
          添加SPU
        </el-button>
        <el-table style="margin: 10px 0" border>
          <el-table-column
            type="index"
            label="序号"
            width="80px"
            align="center"
          />
          <el-table-column label="spu名称" />
          <el-table-column label="spu描述" />
          <el-table-column label="spu操作" />
        </el-table>
        <!--卡片底部 分页器-->
        <!--
          pagination
          ---v-model:current-page：设置当前分页器页码
          ---v-model:page-size:设置每一也展示数据条数
          ---page-sizes：每页显示个数选择器的选项设置
          ---:small="" ：值为布尔值，表示分页器大小，默认为false，大
          ---:disabled ：值为布尔值，是否禁用分页
          ---background:是否为分页按钮添加背景色
          ---layout：分页器6个子组件布局的调整 "->"把后面的子组件顶到右侧
          ---total：一共多少
         -->
        <el-pagination
          v-model:current-page="currentPage"
          v-model:page-size="pageSize"
          :page-sizes="[3, 5, 7, 9]"
          :small="false"
          :disabled="false"
          :background="true"
          layout="prev, pager, next, jumper,->, sizes, total"
          :total="total"
        />
      </div>
      <div v-show="scene === 1"></div>
    </el-card>
  </div>
</template>

<style scoped lang="scss"></style>
```

#### 78 Spu模块展示已有数据

```json
{
  "code": 0,
  "data": {
    "current": 0,
    "hitCount": true,
    "pages": 0,
    "records": [
      {
        "category3Id": 0,//归属哪一个三级分类
        "createTime": "2024-01-23T13:54:23.737Z",
        "description": "string",//spu描述
        "id": 0,//唯一id
        "spuImageList": [],//spu照片墙 //需发请求
        "spuName": "string",//spu名字
        "spuPosterList": [], //所有spu列表 需发请求
        "spuSaleAttrList": [],//spu销售属性 需发请求
        "tmId": 0,
        "updateTime": "2024-01-23T13:54:23.737Z"
      }
    ],
    "searchCount": true,
    "size": 0,
    "total": 0
  },
  "message": "string",
  "ok": true
}
```

##### API

```ts
//spu管理模块接口
import request from '@/utils/request.ts'
import type { HasSpuResponseData } from './type.ts'

enum API {
  //获取spu数据，分页展示
  GETSPU_URL = '/admin/product',
}

export const reqGetSpu = (
  page: number,
  limit: number,
  category3Id: string | number,
) => {
  return request.get<any, HasSpuResponseData>(
    API.GETSPU_URL + `/${page}/${limit}?category3Id=${category3Id}`,
  )
}
```

```ts
//服务器全部接口返回的数据类型
export interface ResponseData {
  code: number
  message: string
  ok: boolean
}
//SPU数据的ts类型:需要修改
// spuSaleAttrList: null //SPU销售属性列表
// spuImageList: null //SPU照片墙的数据
// 注意后台并没有放在一个接口中，这两个字段后期需要发请求获取
export interface SpuData {
  id?: number //id
  spuName: string //SPU名称
  description: string //SPU描述
  category3Id: string | number //三级分类的id
  tmId: number | string //产品归属的品牌id
  spuSaleAttrList: null //SPU销售属性列表
  spuImageList: null //SPU照片墙的数据
}
//数组:元素都是已有SPU数据类型
export type Records = SpuData[]
//定义获取已有的SPU接口返回的数据ts类型
export interface HasSpuResponseData extends ResponseData {
  data: {
    records: Records
    total: number //一共多少spu
    current: number //当前哪一页
    searchCount: boolean //是否有搜索
    pages: number //一共多少页
    size: number //每页多少条
  }
}
```

##### 展示数据

通过监听有无三级分类id，发送请求获取数据

```vue
<script setup lang="ts">
import { ref, watch } from 'vue'
import useCategoryStore from '@/store/modules/category'
import { reqGetSpu } from '@/api/product/spu'
import type { HasSpuResponseData, Records } from '@/api/product/spu/type.ts'
//场景切换
let scene = ref<number>(0)
//分页器默认页码
let currentPage = ref<number>(1)
//每页展示数据个数
let pageSize = ref<number>(3)
//spu数据总数
let total = ref<number>(0)
//分类仓库数据
let categoryStore = useCategoryStore()
//存储已有的spu数据
let spuArr = ref<Records>([])
//监听仓库中三级分类id变化，若变化，发送请求获取数据
watch(
  () => categoryStore.c3Id,
  () => {
    //确保有三级分类id再发请求，当点击一二级时，三级id需要清空
    if (!categoryStore.c3Id) {
      return
    }
    getSpu()
  },
)
//当前页码发生变化事件
//组件pagination回传了数据（当前页码）
watch(currentPage, () => {
  getSpu()
})
//页面size变化时
//组件pagination回传了数据（页大小）
watch(pageSize, () => {
  getSpu()
})
//此方法执行，可以获取某一个三级分类下的所有SPU
const getSpu = async () => {
  let res: HasSpuResponseData = await reqGetSpu(
    currentPage.value,
    pageSize.value,
    categoryStore.c3Id,
  )
  if (res.code === 200) {
    total.value = res.data.total
    spuArr.value = res.data.records
  }
}
</script>

<template>
  <div>
    <Category :scene="scene" />
    <el-card style="margin: 10px 0">
      <div v-show="scene === 0">
        <el-button
          type="primary"
          @click="scene = 1"
          icon="Plus"
          :disabled="!categoryStore.c3Id"
        >
          添加SPU
        </el-button>
        <el-table style="margin: 10px 0" border :data="spuArr">
          <el-table-column
            type="index"
            label="序号"
            width="80px"
            align="center"
          />
          <el-table-column label="spu名称" prop="spuName" />
          <!--
            show-overflow-tooltip ：当内容过长，会折叠
           -->
          <el-table-column
            label="spu描述"
            prop="description"
            show-overflow-tooltip
          />
          <el-table-column label="spu操作">
            <template v-slot="{ row }">
              <el-button
                type="primary"
                size="small"
                icon="Plus"
                title="添加sku"
              ></el-button>
              <el-button
                type="warning"
                size="small"
                icon="Edit"
                title="修改spu"
              ></el-button>
              <el-button
                type="info"
                size="small"
                icon="View"
                title="查看sku"
              ></el-button>
              <el-button
                type="danger"
                size="small"
                icon="Delete"
                title="删除spu"
              ></el-button>
            </template>
          </el-table-column>
        </el-table>
        <!--卡片底部 分页器-->
        <!--
          pagination
          ---v-model:current-page：设置当前分页器页码
          ---v-model:page-size:设置每一也展示数据条数
          ---page-sizes：每页显示个数选择器的选项设置
          ---:small="" ：值为布尔值，表示分页器大小，默认为false，大
          ---:disabled ：值为布尔值，是否禁用分页
          ---background:是否为分页按钮添加背景色
          ---layout：分页器6个子组件布局的调整 "->"把后面的子组件顶到右侧
          ---total：一共多少
         -->
        <el-pagination
          v-model:current-page="currentPage"
          v-model:page-size="pageSize"
          :page-sizes="[3, 5, 7, 9]"
          :small="false"
          :disabled="false"
          :background="true"
          layout="prev, pager, next, jumper,->, sizes, total"
          :total="total"
        />
      </div>
      <div v-show="scene === 1"></div>
    </el-card>
  </div>
</template>
```

#### 79 spu场景一的搭建与切换

在*views/product/spu*下新建spuForm和skuForm组件

spuForm

```vue
<script setup lang="ts">
let $emit = defineEmits(['changeScene'])
//保存时切换成场景一
const onSubmit = () => {
  $emit('changeScene', 0)
}
//取消时切换成场景一
const onCancel = () => {
  $emit('changeScene', 0)
}
</script>

<template>
  <!--添加新的spu或者修改spu，场景一-->
  <div>
    <el-form label-width="100px">
      <el-form-item label="spu名称">
        <el-input placeholder="请输入spu名称"></el-input>
      </el-form-item>
      <el-form-item label="spu品牌">
        <el-select placeholder="请选择spu品牌">
          <el-option label="品牌1" value="brand1"></el-option>
          <el-option label="品牌2" value="brand2"></el-option>
        </el-select>
      </el-form-item>
      <el-form-item label="spu描述">
        <el-input placeholder="请输入spu描述" type="textarea"></el-input>
      </el-form-item>
      <el-form-item label="spu图片">
        <el-upload
          v-model:file-list="fileList"
          action="https://run.mocky.io/v3/9d059bf9-4660-45f2-925d-ce80ad6c4d15"
          list-type="picture-card"
          :on-preview="handlePictureCardPreview"
          :on-remove="handleRemove"
        >
          <el-icon><Plus /></el-icon>
        </el-upload>
        <el-dialog v-model="dialogVisible">
          <img w-full :src="dialogImageUrl" alt="Preview Image" />
        </el-dialog>
      </el-form-item>
      <el-form-item label="spu销售属性">
        <el-select placeholder="请选择spu品牌">
          <el-option label="品牌1" value="brand1"></el-option>
          <el-option label="品牌2" value="brand2"></el-option>
        </el-select>
        <el-button type="primary" icon="Plus" style="margin: 0 10px">
          添加销售属性
        </el-button>
        <el-table style="margin: 10px 0" border>
          <el-table-column
            type="index"
            label="序号"
            width="80px"
            align="center"
          ></el-table-column>
          <el-table-column label="销售属性名" width="120px"></el-table-column>
          <el-table-column label="销售属性值"></el-table-column>
          <el-table-column label="操作" width="120px"></el-table-column>
        </el-table>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="onSubmit">保存</el-button>
        <el-button @click="onCancel">取消</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>
```

skuForm

```vue
<script setup lang="ts"></script>

<template>
  <!--添加新的sku，场景二-->
  <div>
    <h1>add new sku</h1>
  </div>
</template>
```

index

```vue
<script setup lang="ts">
import { ref, watch } from 'vue'
import useCategoryStore from '@/store/modules/category'
import { reqGetSpu } from '@/api/product/spu'
import type { HasSpuResponseData, Records } from '@/api/product/spu/type.ts'
//引入子组件，场景1添加/修改spu和场景2添加sku
import SkuForm from '@/views/product/spu/skuForm.vue'
import SpuForm from '@/views/product/spu/spuForm.vue'
//场景切换
let scene = ref<number>(0)
.......
//按钮点击事件
const addSpu = () => {
  scene.value = 1
}
const addSku = () => {
  scene.value = 2
}
const editSpu = () => {
  scene.value = 1
}
const viewSku = () => {}
const delSpu = () => {}

//子组件自定义事件触发
//子组件spuForm触发父组件事件，修改当前场景为0
const changeScene = (num: number) => {
  scene.value = num
}
</script>

<template>
  <div>
    <Category :scene="scene" />
    <el-card style="margin: 10px 0">
      <div v-show="scene === 0">
        <el-button
          type="primary"
          @click="addSpu"
          icon="Plus"
          :disabled="!categoryStore.c3Id"
        >
          添加SPU
        </el-button>
        <el-table style="margin: 10px 0" border :data="spuArr">
          .......
        </el-table>
        <!--卡片底部 分页器-->
        ......
      </div>
      <!--添加新的spu或者修改spu，场景一 changeScene为自定义事件-->
      <SpuForm v-show="scene === 1" @changeScene="changeScene"></SpuForm>
      <!--添加新的sku，场景二-->
      <SkuForm v-show="scene === 2"></SkuForm>
    </el-card>
  </div>
</template>
```

#### 80 spu模块api书写和ts类型

修改和添加的页面是差不多的。页面1的四个地方都需要发请求拿数据，我们在这一部分分别编写4个部分的API以及ts类型

![img](https://raw.githubusercontent.com/balance-hy/typora/master/2023img/202401291114979.png)



##### SPU品牌数据

```json
{
  "code": 0,
  "data": [
    {
      "createTime": "2024-01-29T02:52:24.391Z",
      "id": 0,
      "logoUrl": "string",
      "tmName": "string",
      "updateTime": "2024-01-29T02:52:24.391Z"
    }
  ],
  "message": "string",
  "ok": true
}
```

*src\api\product\spu\index.ts*

```ts
//获取全部品牌的数据
ALLTRADEMARK_URL = '/admin/product/baseTrademark/getTrademarkList',
//获取全部的SPU的品牌的数据
export const reqAllTradeMark = () => {
  return request.get<any, AllTradeMark>(API.ALLTRADEMARK_URL)
}
```

*src\api\product\spu\type.ts*

```ts
//品牌数据的TS类型
export interface Trademark {
  id: number
  tmName: string
  logoUrl: string
}
//品牌接口返回的数据ts类型
export interface AllTradeMark extends ResponseData {
  data: Trademark[]
}
```

##### spu图片数据

```json
{
  "code": 0,
  "data": [
    {
      "createTime": "2024-01-29T02:52:24.250Z",
      "id": 0,
      "imgName": "string",
      "imgUrl": "string",
      "spuId": 0,
      "updateTime": "2024-01-29T02:52:24.250Z"
    }
  ],
  "message": "string",
  "ok": true
}
```

*src\api\product\spu\index.ts*

```ts
//获取某个SPU下的全部的售卖商品的图片数据
IMAGE_URL = '/admin/product/spuImageList',
//获取某一个已有的SPU下全部商品的图片地址
export const reqSpuImageList = (spuId: number) => {
  return request.get<any, SpuHasImg>(API.IMAGE_URL + `/${spuId}`)
}
```

```ts
//品牌数据的TS类型
export interface Trademark {
  id: number
  tmName: string
  logoUrl: string
}
//品牌接口返回的数据ts类型
export interface AllTradeMark extends ResponseData {
  data: Trademark[]
}
```

##### spu全部销售属性

![image-20240130113847980](https://raw.githubusercontent.com/balance-hy/typora/master/2023img/202401301138221.png)

```json
{
  "code": 0,
  "data": [
    {
      "baseSaleAttrId": 0,
      "createTime": "2024-01-29T02:52:24.254Z",
      "id": 0,
      "saleAttrName": "string",
      "spuId": 0,
      "spuSaleAttrValueList": [
        {
          "baseSaleAttrId": 0,
          "createTime": "2024-01-29T02:52:24.254Z",
          "id": 0,
          "isChecked": "string",
          "saleAttrName": "string",
          "saleAttrValueName": "string",
          "spuId": 0,
          "updateTime": "2024-01-29T02:52:24.254Z"
        }
      ],
      "updateTime": "2024-01-29T02:52:24.254Z"
    }
  ],
  "message": "string",
  "ok": true
}
```

*src\api\product\spu\index.ts*

```ts
//获取整个项目全部的销售属性[颜色、版本、尺码]
ALLSALEATTR_URL = '/admin/product/baseSaleAttrList',
//获取全部的销售属性
export const reqAllSaleAttr = () => {
  return request.get<any, HasSaleAttrResponseData>(API.ALLSALEATTR_URL)
}
```

```ts
//已有的全部SPU的销售属性返回数据ts类型
export interface HasSaleAttr {
  id: number
  name: string
}
export interface HasSaleAttrResponseData extends ResponseData {
  data: HasSaleAttr[]
}
```

##### spu已有销售属性

```ts
//获取某一个SPU下全部的已有的销售属性接口地址
SPUHASSALEATTR_URL = '/admin/product/spuSaleAttrList/',
//获取某一个已有的SPU拥有多少个销售属性
export const reqSpuHasSaleAttr = (spuId: number) => {
  return request.get<any, SaleAttrResponseData>(API.SPUHASSALEATTR_URL + spuId)
}
```

```ts
//已有销售属性值ts类型
export interface SaleAttrValue {
  id?: number
  createTime: null
  updateTime: null
  spuId: number
  baseSaleAttrId: number
  saleAttrName: string
  saleAttrValueName: string
  isChecked: null
}
//已有销售属性值数组类型
export type spuSaleAttrValueList = SaleAttrValue[]
//已有销售属性对象ts类型
export interface SaleAttr {
  id?: number
  createTime: null
  updateTime: null
  spuId?: number
  baseSaleAttrId: number | string
  saleAttrName: string
  spuSaleAttrValueList: spuSaleAttrValueList
}
//SPU已有的销售属性接口返回数据ts类型
export interface SaleAttrResponseData extends ResponseData {
  data: SaleAttr[]
}
```

#### 81 修改spu获取数据

首先：SPU的数据应该分为5部分：

* 第一部分：是父组件里的展示的数据，也是我们点击修改按钮时的那个数据。
* 其余4个部分的数据需要我们发请求得到。

问题1：子组件需要用到父组件中的数据，应该怎么办？答：要传递的数据是指定的，也就是我们点击修改时的数据。通过ref的方式，拿到子组件时的实例，再调用子组件暴露的方法将数据做为参数传递过去。当然也可以用props传，但引出问题2

问题2：其余4个部分的数据什么时候获取。答：同样的在点击修改按钮时获取，因为使用v-show,无法在挂载时发请求获取数据，子组件如果想要初始化其数据，必须在切换场景时获取，为简便起见，可以对外暴露方法，父组件获取其实例调用，从而初始化。

##### 第一部分数据

*views/product/spu/index*

```html
<!--添加新的spu或者修改spu，场景一-->
      <SpuForm
+       ref="spu"
        v-show="scene === 1"
        @changeScene="changeScene"
      ></SpuForm>
```

```ts
//获取spuForm实例
let spu = ref()
```

子组件暴露对外函数

*views/product/spu/spuForm*

```vue
defineExpose({ initHasSpuData })
```

修改按钮点击函数中调用子组件函数，并传递**第一部分数据**

```html
<el-button
                type="warning"
                size="small"
                icon="Edit"
                title="修改spu"
                @click="editSpu(row)"
              ></el-button>
```

```ts
const editSpu = (row: SpuData) => {
  scene.value = 1
  //调用子组件spuform实例方法获取完整已有的spu数据
  spu.value.initHasSpuData(row)
}
```

##### 其余数据

子组件中发起请求，并且将服务器返回的四个数据存储，加上参数传递的第一部分数据，这样子组件拿到了全部的数据。

```ts
//-----------------变量声明区----------------------------
let $emit = defineEmits(['changeScene'])
//所有品牌数据
let AllTradeMark = ref<Trademark[]>([])
//图片列表
let imgList = ref<SpuImg[]>([])
//已有spu销售属性
let saleAttr = ref<SaleAttr[]>([])
//全部销售属性
let allSaleAttr = ref<HasSaleAttr[]>([])

//-------------方法区-----------------
//初始化数据
const initHasSpuData = async (spu: SpuData) => {
  //spu:即为父组件传递过来的已有的SPU对象，但数据并不完整,需要发送请求
  let res = await reqAllTradeMark()
  let res1 = await reqSpuImageList(spu.id as number)
  let res2 = await reqSpuHasSaleAttr(spu.id as number)
  let res3 = await reqAllSaleAttr()
  if (
    res.code === 200 &&
    res1.code === 200 &&
    res2.code === 200 &&
    res3.code === 200
  ) {
    AllTradeMark.value = res.data //所有品牌
    imgList.value = res1.data //图片列表
    saleAttr.value = res2.data //已有销售属性
    allSaleAttr.value = res3.data //全部销售属性
  }
}
```

#### 82 添加或修改spu api

spu对象数据

```json
{
  "id": 0,//添加无需id，更新需要定义
  "spuName": "string",//spu名字
  "tmId": 0,//该spu归属于哪个品牌id
  "description": "string",//spu描述
  "category3Id": 0,//给哪个三级分类增加或修改
  "createTime":null ,
  "updateTime": null,
  "spuImageList": [ //图片数据
    {
      "id": 0,//添加没有
      "imgName": "string",
      "imgUrl": "string",
      "spuId": 0,//可有可无
      "updateTime": "2024-01-30T02:25:56.528Z",//可有可无
      "createTime": "2024-01-30T02:25:56.528Z",//可有可无
    }
  ],
  "spuSaleAttrList": [//销售属性列表
    {
      "baseSaleAttrId": 0,//销售属性id
      "createTime": "2024-01-30T02:25:56.528Z",
      "id": 0,
      "saleAttrName": "string",//销售属性名字
      "spuId": 0,
      "spuSaleAttrValueList": [//销售属性值列表
        {
          "baseSaleAttrId": 0,
          "createTime": "2024-01-30T02:25:56.528Z",
          "id": 0,
          "isChecked": "string",
          "saleAttrName": "string",
          "saleAttrValueName": "string",//销售属性值的名字
          "spuId": 0,
          "updateTime": "2024-01-30T02:25:56.528Z"
        }
      ],
      "updateTime": "2024-01-30T02:25:56.528Z"
    }
  ],
}
```

```ts
//追加一个新的SPU
ADDSPU_URL = '/admin/product/saveSpuInfo',
//更新已有的SPU
UPDATESPU_URL = '/admin/product/updateSpuInfo',

//追加一个新的SPU/更新已有的SPU 有无id
export const reqAddOrUpdateSpu = (data: SpuData) => {
  //若有id，则是更新，否则是添加
  if (data.id) {
    return request.post<any, any>(API.UPDATESPU_URL, data)
  }
  return request.post<any, any>(API.ADDSPU_URL, data)
}
```

ts类型修改详见commit 82

#### 83 展示与收集已有的spu

##### 存储父组件传递的数据

```ts
//存储已有spu的对象 新增无id
let spuParams = ref<SpuData>({
  spuName: '',
  description: '',
  category3Id: '',
  tmId: '',
  spuSaleAttrList: [],
  spuImageList: [],
})
//-------------方法区-----------------
//初始化数据
const initHasSpuData = async (spu: SpuData) => {
  //获取已有的spu，存储起来
  spuParams.value = spu
  .......
}
```

##### 展示spu名称

```vue
<el-input
          placeholder="请输入spu名称"
          v-model="spuParams.spuName"
          ></el-input>
```

##### 展示spu品牌

```vue
<el-form-item label="spu品牌">
        <el-select v-model="spuParams.tmId">
          <el-option
            v-for="item in AllTradeMark"
            :key="item.id"
            :label="item.tmName"
            :value="item.id"
          />
        </el-select>
      </el-form-item>
```

注意el-option中value是选项值，还需要在el-select中绑定选中的值

##### spu描述

```vue
<el-form-item label="spu描述">
        <el-input
          placeholder="请输入spu描述"
          type="textarea"
          v-model="spuParams.description"
        ></el-input>
      </el-form-item>
```

#### 84 修改spu中照片墙数据收集

在照片收集时，发现总是上传不成功，怀疑是服务器问题，但没办法显示真实请求地址，通过bypass函数来打印真实地址

```ts
//代理跨域
    server: {
      proxy: {
        [env.VITE_APP_BASE_API]: {
          //获取数据服务器地址的设置
          target: env.VITE_SERVE,
          //是否需要代理跨域
          changeOrigin: true,
          //路径重写，因为服务器地址没有/dev-api，替换为空串
          rewrite: (path) => path.replace(/^\/dev-api/, ''),
          //bypass可以用于绕过代理，此处用函数截获请求，添加到响应头中，从而看见真实请求地址
          bypass(req, res, options: any) {
            const proxyURL = options.target + options.rewrite(req.url);
            res.setHeader('x-req-proxyURL', proxyURL); // 设置响应头，从而看到
            //直接打印也可以
            //console.log('proxyURL', proxyURL)
          },
        },
      },
    },
  }
```

```vue
<el-form-item label="spu图片">
        <!--
           upload组件
           v-model:file-list：文件列表，展示默认图片，需要类型 UploadUserFile[]，其中字段为
                               name：文件名，url：文件路径，注意我们的参数中是imgName，imgUrl
           list-type：文件列表的类型
           action：上传图片请求地址 注意/admin/product/fileUpload这样不行，因为代理服务器没有/api不转发
                   所以必须为/api/admin/product/fileUpload，考虑到生产环境的正确运行，此处应动态绑定前缀
           show-file-list：是否显示已上传的文件列表，默认为 true
           on-success：上传成功的回调
           before-upload：上传前的回调，可以用来限制上传 参数为上传的文件
        -->
        <el-upload
          v-model:file-list="imgList"
          :action="actionUrl"
          list-type="picture-card"
          :on-preview="handlePictureCardPreview"
          :on-remove="handleRemove"
        >
          <el-icon><Plus /></el-icon>
        </el-upload>
        <el-dialog v-model="dialogVisible">
          <img w-full :src="dialogImageUrl" alt="Preview Image" />
        </el-dialog>
      </el-form-item>
```

```ts
//图片上传地址
let actionUrl = ref<string>(
  import.meta.env.VITE_APP_BASE_API + '/admin/product/fileUpload',
)
//预览图片地址
const dialogImageUrl = ref('')
//预览对话框显示与隐藏
const dialogVisible = ref(false)

//照片墙点击预览时触发事件
const handlePictureCardPreview: UploadProps['onPreview'] = (uploadFile) => {
  dialogImageUrl.value = uploadFile.url!
  dialogVisible.value = true
}
//照片墙点击删除时触发事件
const handleRemove: UploadProps['onRemove'] = (uploadFile, uploadFiles) => {
  console.log(uploadFile, uploadFiles)
}
```

**注意ts在字段后加！，表示非空断言，即字段不为空，从而避免警告**

#### 85 展示已有销售属性和属性值

数据结构如下：

```ts
export interface SaleAttr {
  id?: number
  createTime?: null
  updateTime?: null
  spuId?: number
  baseSaleAttrId: number | string
  saleAttrName: string
  spuSaleAttrValueList: spuSaleAttrValueList
}
```

展示已有销售属性和属性值，也就是四列

```vue
<el-table style="margin: 10px 0" border :data="saleAttr">
    <el-table-column
                     type="index"
                     label="序号"
                     width="80px"
                     align="center"
                     ></el-table-column>
    <el-table-column
                     label="销售属性名"
                     width="120px"
                     prop="saleAttrName"
                     ></el-table-column>
    <el-table-column label="销售属性值">
        <!--row即为已有销售属性对象-->
        <template v-slot="{ row }">
<el-tag
        v-for="tag in row.spuSaleAttrValueList"
        :key="tag.id"
        class="mx-1"
        closable
        style="margin: 0 5px"
        >
    {{ tag.saleAttrValueName }}
            </el-tag>
<el-button type="success" icon="Plus" size="small" />
        </template>
    </el-table-column>
    <el-table-column label="操作" width="120px">
        <template v-slot="{ $index }">
<el-button
           type="danger"
           icon="Delete"
           size="small"
           @click="saleAttr.splice($index, 1)"
           />
        </template>
    </el-table-column>
</el-table>
```

#### 86 完成收集新增销售属性

首先计算出还有多少销售属性

```ts
//将来收集还未选择的销售属性的Id和属性值的名字
let saleAttrIdAndValueName = ref<string>('')
//计算属性计算还有什么销售属性未选择
let unSelectSaleAttr = computed(() => {
  //全部销售属性:颜色、版本、尺码
  //已有的销售属性:颜色、版本
  let arr = allSaleAttr.value.filter((item) => {
    return saleAttr.value.every((item1) => {
      return item.name !== item1.saleAttrName
    })
  })
  return arr
})
```

然后收集数据

```vue
 <el-form-item label="spu销售属性">
        <el-select
          :placeholder="`还有${unSelectSaleAttr.length}个未选择`"
          v-model="saleAttrIdAndValueName"
        >
          <!--之后要收集其id和名字为对象键值，所以value写成${item.id}:${item.name}--->
          <el-option
            v-for="item in unSelectSaleAttr"
            :key="item.id"
            :label="item.name"
            :value="`${item.id}:${item.name}`"
          ></el-option>
        </el-select>
        <el-button
          :disabled="!saleAttrIdAndValueName"
          type="primary"
          icon="Plus"
          style="margin: 0 10px"
          @click="addSaleAttr"
        >
          添加销售属性
        </el-button>
```

最后完善添加销售属性事件

```ts
//添加销售属性
const addSaleAttr = () => {
  /*
    添加销售属性，这三个字段必须要有
    "baseSaleAttrId": number, //销售属性id
    "saleAttrName": string, //销售属性名
    "spuSaleAttrValueList": SpuSaleAttrValueList //销售属性值
  */
  const [baseSaleAttrId, saleAttrName] = saleAttrIdAndValueName.value.split(':')
  // key value一致,省略value
  let newSaleAtt: SaleAttr = {
    baseSaleAttrId,
    saleAttrName,
    spuSaleAttrValueList: [],
  }
  saleAttr.value.push(newSaleAtt)
  //添加完清空选择器中值
  saleAttrIdAndValueName.value = ''
}
```

#### 87 展示与收集已有spu业务完成

点击添加属性值按钮时，需要切换成输入框，这就要利用动态添加字段来进行实现。

```vue
<el-tag
                v-for="(tag, $index) in row.spuSaleAttrValueList"
                :key="tag.id"
                class="mx-1"
                closable
+                @close="row.spuSaleAttrValueList.splice($index, 1)"
                style="margin: 0 5px"
              >
                {{ tag.saleAttrValueName }}
              </el-tag>
              <el-input
+                v-if="row.flag == true"
                size="small"
                placeholder="请输入属性值"
                style="width: 100px"
+                @blur="toLook(row)"
+                v-model="row.saleAttrValue"
              />
              <el-button
+                v-else
                type="success"
                icon="Plus"
                size="small"
+                @click="toEdit(row)"
              />
```

添加按钮让flag变为true，从而切换成输入框，然后将输入框绑定的字段置空

```ts
//添加属性值按钮点击事件
const toEdit = (row: SaleAttr) => {
  //点击按钮的时候，input组件显示
  row.flag = true
  //将input框中数据收集到该字段
  row.saleAttrValue = ''
}
```

当输入框失去焦点后，保存得到的属性值并做校验

```ts
//失去焦点转为按钮模式
const toLook = (row: SaleAttr) => {
  //整理收集的属性的ID和属性值的名字
  const { baseSaleAttrId, saleAttrValue } = row
  //判断非法情况，若有一个为空，则直接返回
  if (saleAttrValue!.trim() == '') {
    ElMessage({
      type: 'warning',
      message: '属性值不能为空',
    })
    return
  }
  //判断该属性值是否已经存在
  let isRepeat = row.spuSaleAttrValueList.some((item) => {
    return item.saleAttrValueName == saleAttrValue!.trim()
  })
  if (isRepeat) {
    ElMessage({
      type: 'warning',
      message: '属性值不能重复',
    })
    return
  }
  //整理成服务器需要的形式
  let newSaleAttrValue: SaleAttrValue = {
    baseSaleAttrId,
    saleAttrValueName: saleAttrValue!,
  }
  //添加
  row.spuSaleAttrValueList.push(newSaleAttrValue)
  //修改flag
  row.flag = false
}
```

完善属性删除操作

```vue
<el-table-column label="操作" width="120px">
            <template v-slot="{ $index }">
              <el-button
                type="danger"
                icon="Delete"
                size="small"
                @click="saleAttr.splice($index, 1)"
              />
            </template>
          </el-table-column>
```

#### 88 完成修改已有spu的业务

```ts
//保存时切换成场景一
const onSubmit = async () => {
  //整理参数
  //注意照片墙的数据字段不对应，需要将name和url转化为imgName和imgUrl
  //其中新增的照片url应该是response.data中的url
  spuParams.value.spuImageList = imgList.value.map((item: any) => {
    return {
      imgName: item.name,
      imgUrl: (item.response && item.response.data) || item.url,
    }
  })
  //销售属性数据
  spuParams.value.spuSaleAttrList = saleAttr.value
  //发请求
  let res = await reqAddOrUpdateSpu(spuParams.value)
  if (res.code == 200) {
    ElMessage({
      type: 'success',
      message: spuParams.value.id ? '添加成功' : '修改成功',
    })
    $emit('changeScene', 0)
  } else {
    ElMessage({
      type: 'error',
      message: spuParams.value.id ? '添加失败' : '修改失败',
    })
  }
}
```

在index.vue中再获取一次数据

```ts
//子组件自定义事件触发
//子组件spuForm触发父组件事件，修改当前场景为0
const changeScene = (num: number) => {
  scene.value = num
  //再次获取更新后的数据
  getSpu()
}
```

#### 89 完成添加新spu业务

在父组件调用添加按钮回调

```ts
//按钮点击事件
const addSpu = () => {
  scene.value = 1
  //调用子组件spuform实例方法初始化数据
  spu.value.initAddSpuData(categoryStore.c3Id)
}
```

子组件补全方法

```ts
//初始化数据-》添加spu
const initAddSpuData = async (c3Id: number | string) => {
  //清空数据
  Object.assign(spuParams.value, {
    spuName: '',
    description: '',
    category3Id: '',
    tmId: '',
    spuSaleAttrList: [],
    spuImageList: [],
  })
  imgList.value = []
  saleAttr.value = []
  saleAttrIdAndValueName.value = ''
  if (Object.prototype.hasOwnProperty.call(spuParams.value, 'id')) {
    delete spuParams.value.id
  }
  //获取全部品牌数据
  let res = await reqAllTradeMark()
  //获取全部销售属性
  let res3 = await reqAllSaleAttr()
  if (res.code === 200 && res3.code === 200) {
    AllTradeMark.value = res.data
    allSaleAttr.value = res3.data
  }
  spuParams.value.category3Id = c3Id
}
defineExpose({ initHasSpuData, initAddSpuData })
```

对于添加或者更新的跳转指定页面没有实现。





## 五、问题解决

### 导入报错

在导入时，常常会出现Cannot find module ‘@/views/test/index.vue‘ or its corresponding type declarations.ts(2307)

这是由于TypeScript无法正确解析动态导入的路径而导致的

尽管你在项目中没有遇到问题，但TypeScript的类型检查器仍然会发出警告或错误，因为它无法找到相应的类型声明文件。

要解决这个问题，你可以在[Vue项目](https://so.csdn.net/so/search?q=Vue项目&spm=1001.2101.3001.7020)的根目录下创建一个`typings.d.ts`（或者其他任何你喜欢的名称）的文件，并在其中添加以下内容：

```ts
declare module '*.vue' {
  import { DefineComponent } from 'vue';
  const component: DefineComponent<{}, {}, any>;
  export default component;
}
```

然后在ts.config.json中引入.d.ts

```json
"include": ["src/**/*.ts", "src/**/*.d.ts","src/**/*.tsx", "src/**/*.vue"],
```

## 六、项目的资源地址

贾成豪老师代码仓库地址:https://gitee.com/jch1011/vue3_admin_template-bj1.git

项目在线文档:

服务器域名:http://sph-api.atguigu.cn

swagger文档:

http://139.198.104.58:8209/swagger-ui.html

http://139.198.104.58:8212/swagger-ui.html#/

echarts:国内镜像网站

https://www.isqqw.com/echarts-doc/zh/option.html#title

http://datav.aliyun.com/portal/school/atlas/area_selector
