# MiniZinc

## 基本使用

### 注释

```
/* */
%
```

### 变量声明

基本的 参数类型 包括 整型 (`int`)， 浮点型(`float`)， 布尔型 (`bool`) 以及 字符串型 (`string`)。 同时也支持数组和集合。

 如果一个参数出现在了多于一个的赋值中，就会出现错误。

```
int: nc = 3;
等价于
int: nc;
nc = 3;
```

### 决策变量

对于每一个决策变量，我们需要给出变量可能的取值集合。这个被称为变量的 *定义域* 。 定义域部分可以在 变量声明 的时候同时给出， 这时决策变量的 类型 就会从定义域中的数值的类型推断出。

```
var 1..nc: a; 
```

上面的语句声明了一个名为 a 定义域为 1-nc的决策变量

### 约束

```
constraint wa != nt;
```

上面描述了一个不等的约束

MiniZinc提供了以下关系操作符 关系操作符 ：

相等 (`=` or `==`), 不等 (`!=`), 小于 (`<`), 大于 (`>`), 小于等于 (`<=`), and 和大于等于 (`>=`).

### 指明类型

#### 满足问题

我们希望给决策变量找到一个值使得约束被满足，但具体是哪一个值却没有所谓。

```
solve satisfy;
```

最大化

```
solve maximize <算术表达式>;
```

最小化

```
solve minimize <算术表达式>;
```

### 输出

```
output ["wa=\(wa)\t nt=\(nt)\t sa=\(sa)\n",
        "q=\(q)\t nsw=\(nsw)\t v=\(v)\n",
         "t=", show(t),  "\n"];
```

`\n` 代表换行符， `\t` 代表制表符

`\(v)`等价于`show(v)`

数字的 `show` 有各种不同方式的表示： `show_int(n,X)` 在至少$|n|$个字符里输出整型 `X` 的值，若 n>0 则右对齐，否则则左对齐； `show_float(n,d,X)` 在至少 |n| 个字符里输出 浮点型 `X` 的值，若 n>0 则右对齐，否则则左对齐，并且小数点后有 d 个字符。

**长的字符串常量**可以利用字符串连接符 `++` 来分成几行。

我们可以通过点击MiniZinc IDE中的 *Run* 按钮,或者输入

```
$ minizinc --solver Gecode aust.mzn
```

来评估我们的模型。 其中 `aust.mzn` 是包含我们的MiniZinc模型的文件名字。 我们必须使用文件扩展名 `.mzn` 来表明一个MiniZinc模型。 带有 `--solver Gecode` 选项的命令 `minizinc` 使用Gecode有限域求解器去评估我们的模型。

### 操作符

#### assert

MiniZinc提供了一个内置的布尔型操作符 *断言* 用来检查参数值。格式是 `assert(B,S)` 。 布尔型表达式 `B` 被检测。若它是假的，运行中断。此时字符串表达式 `S` 作为错误信息被输出。 如果我们想当面粉的份量是负值的时候去检测出并且产生合适的错误信息，我们可以直接加入下面的一行

```
constraint assert(flour >= 0,"Amount of flour is non-negative");
```

到我们的模型中。注意 *断言* 表达式是一个布尔型表达式，所以它被看做是一种类型的约束。我们可以加入类似的行来检测其他原料的份量是否是非负值。

### 引用

引用项 允许另外一个文件的内容被插入模型中。 它们有以下形式：

```
include <文件名>;
```

其中 `<文件名>` 是一个字符串常量。 它们使得大的模型可以被分为小的子模型以及包含库文件中定义的约束

## 进阶

### 集合

集合变量用以下方式声明

```
set of <类型-实例化> : <变量名> ;

例如 下列代码声明了一个0-h的整形集合
set of int: HEIGHT = 0..h;
```

整型，枚举型（参见后面），浮点型和布尔型集合都可以定义。 **决策变量**集合**只可以是类型为整型或者枚举型**的变量集合。

#### 集合操作符

- 元素属于 (`in`)
- (非严格的) 集合包含 (`subset`)
- (非严格的) 超集关系 (`superset`)
- 并集 (`union`)
- 交集 (`intersect`)
- 集合差运算 (`diff`)
- 集合对称差 (`symdiff`) 
- 集合元素的个数 (`card`)

#### 集合约束

MiniZinc另外一个强大的建模特征是它允许包含整数的集合是决策变量：这表示当模型被评估时，求解器会查找哪些元素在集合中。

举个简单的例子， *0/1背包问题* 。这个问题是背包问题的局限版本，即我们或者选择把物品放入背包或者不放。每一个物品有一个重量和一个利润，在受限制于背包不能太满的条件下，我们想找到选取哪些物品会得到最大化利润。

很自然地，我们在MiniZinc中使用单个的决策变量来建模： `var set of ITEM: knapsack` 其中 `ITEM` 是可放置的物品集合。如果数组 `weight[i]` 和 `profit[i]` 分别 给出物品 `i` 的重量和利润，以及背包可以装载的最大重量是 `capacity`，则一个自然的模型在 [Listing 2.2.13](https://www.minizinc.org/doc-2.8.3/chi/modelling2.html#ex-knapsack-binary) 中给出。

```
enum ITEM;
int: capacity;

array[ITEM] of int: profits;
array[ITEM] of int: weights;

var set of ITEM: knapsack;

constraint sum (i in knapsack) (weights[i]) <= capacity;

solve maximize sum (i in knapsack) (profits[i]) ;

output ["knapsack = \(knapsack)\n"];
```

### 枚举

枚举类型，我们称为 `enums` , 用以下方式声明

```
enum <变量名> ;        enum Products;
```

一个枚举类型用以下赋值的方式定义

```
enum <变量名> = { <变量名-1>, ..., <变量名-n> } ;  enum Products = { BananaCake, ChocolateCake };
```

其中 `<变量名-1>`, …, `<变量名-n>` 是名为 `<变量名>` 的枚举类型中的元素。 通过这个定义，枚举类型中的每个元素也被有效地声明为这个类型的一个新的常量。 声明和定义可以像往常一样结合为一行。

### 数组

MiniZinc提供一维和多维数组。它们用以下类型来声明：

```
array [ <下标集合-1>, ..., <下标集合-n> ] of <类型-实例化>
```

示例

```
enum Products = { BananaCake, ChocolateCake };
array[Products] of int: profit=[400, 450];;
```

意思是香蕉蛋糕的利润是400，而巧克力蛋糕的利润是450。 在内部， `BananaCake` 会被看成是像整数1一样，而 `ChocolateCake` 会被看成像整数2一样。

MiniZinc要求数组声明要给出每一维的下标集合。下标集合或者是一个整型范围，一个 被初始化为整型范围的集合变量，或者是一个 枚举类型 。 数组可以是所有的基类型：整型，枚举型，布尔型，浮点型或者字符串型。 这些可以是固定的或者不固定的，除了字符串型，它只可以是参数。数组也可以作用于 集合但是不可以作用于数组

**二维数组**

```
array[Products, Resources] of int: consumption=[| 250, 2, 75, 100, 0,
              | 200, 0, 150, 150, 75 |]; 
```

其中第一个下标是行下标，而第二个下标是列下标。

注意分隔符 `|` 是怎样被用来分隔行的。

一维数组常量 有以下格式

```
[ <表达式-1>, ..., <表达式-n> ]
```

而 二维数组常量 有以下格式

```
[| <表达式-1-1>, ..., <表达式-1-n> |
   ...                         |
   <表达式-m-1>, ..., <表达式-m-n> |]
```

其中这个数组有 `m` 行 `n` 列。

**多维数组**

```
array<n>d(<下标集合-1>, ..., <下标集合-n>, <列表>)
```

返回一个 `n` 维的数组，它的下标集合在前 `n` 个参数给出，最后一个参数包含了数组的元素。 例如 `array2d(1..3, 1..2, [1, 2, 3, 4, 5, 6])` 和 `[|1, 2 |3, 4 |5, 6|]` 是相等的。

内建函数`length` 返回一维数组的长度。

串联操作符 `++` 可以被用来串联两个一维的数组。 结果得到一个列表，即一个元素从1索引的一维数组。 例如 `[4000, 6] ++ [2000, 500, 500]` 求得 `[4000, 6, 2000, 500, 500]` 。

### 列表推导式

例如，列表推导式 `[i + j | i, j in 1..3 where j < i]` 算得 `[2 + 1, 3 + 1, 3 + 2]` 等同于 `[3, 4, 5]` 。 `[3, 4, 5]` 只是一个下标集合为 `1..3` 的数组。

MiniZinc同时也提供了集合推导式，它有类似的语法：例如 `{i + j | i, j in 1..3 where j < i}` 计算得到集合 `{3, 4, 5}` 。

列表推导式的一般格式是

```
[ <表达式> | <生成元表达式> ]
```

`<表达式>` 指明了如何从 `<生成元表达式>` 产生的元素输出列表中创建元素。 生成元 `<generator-exp>` 由逗号分开的一列生成元表达式组成，选择性地跟着一个布尔型表达式。 两种格式是

```
<生成元>, ..., <生成元>
<生成元>, ..., <生成元> where <布尔表达式>
```

第二种格式中的可选择的 `<布尔型表达式>` 被用作生成元表达式的过滤器：只有满足布尔型表达式的输出列表中的元素才被用来构建元素。

生成元 `<generator>` 有以下格式

```
<标识符>, ..., <标识符> in <数组表达式>
```

每一个标识符是一个 *迭代器* ，轮流从数值表达式中取值，最后一个标识符变化的最迅速。

**列表推导式的生成元和 `<布尔型表达式>` 通常不会涉及决策变量。如果它们确实涉及了决策变量，那么产生的列表是一列 `var opt <T>` ，其中$T$是 `<表达式>` 的类型。**

集合推导式 几乎和列表推导式一样：唯一的不同是这里使用 `{` 和 `}` 括住表达式而不是 `[` 和 `]` 。**集合推导式生成的元素必须是固定的 fixed ，即不能是决策变量**。类似的，集合推导式的生成元和可选择的 `<布尔型表达式>` 必须是固定的。

### 聚合函数

MiniZinc提供了一系列的可以把一维数组的元素聚合起来的内建函数。它们中最有用的可能是 `forall` 。它接收一个布尔型表达式数组（即，约束），返回单个布尔型表达式，它是对数组中的布尔型表达式的逻辑合取。

例如，以下表达式

```
forall( [a[i] != a[j] | i,j in 1..3 where i < j])
```

其中 `a` 是一个下标集合为 `1..3` 的算术数组。它约束了 `a` 中的元素是互相不相同的。列表推导式计算得到 `[ a[1] != a[2], a[1] != a[3], a[2] != a[3] ]` ，所以 `forall` 函数返回逻辑合取 `a[1] != a[2] /\ a[1] != a[3] /\ a[2] != a[3]` 。

**算术数组的 *聚合函数* 有:**

-  `sum` 把元素加起来，
-  `product` 把元素乘起来
- `min` 返回数组中的最小元素
-  `max` 各自返回数组最大元素 

当作用于一个空的数组时， `min` 和 `max` 返回一个运行错误， `sum` 返回0， `product` 返回1。

MiniZinc允许使用一个特别的聚合函数的语法。 建模者不仅仅可以用

```
forall( [a[i] != a[j] | i,j in 1..3 where i < j])
```

也可以用一个更加数学的表示

```
forall (i,j in 1..3 where i < j) (a[i] != a[j])
```

两种表达方式是完全相等的：建模者可以自由使用任何一个他们认为更自然的表达方式。

### 全局约束

MiniZinc包含了一个全局约束的库，这些全局约束也可以被用来定义模型。一个例子是 `alldifferent` 约束，它要求所有参数中的变量都必须是互相不相等的。

```
include "alldifferent.mzn";

var 1..9: S;
var 0..9: E;
var 0..9: N;
var 0..9: D;
var 1..9: M;
var 0..9: O;
var 0..9: R;
var 0..9: Y;

constraint           1000 * S + 100 * E + 10 * N + D
                   + 1000 * M + 100 * O + 10 * R + E
       = 10000 * M + 1000 * O + 100 * N + 10 * E + Y;

constraint alldifferent([S,E,N,D,M,O,R,Y]);

solve satisfy;

output ["   \(S)\(E)\(N)\(D)\n",
        "+  \(M)\(O)\(R)\(E)\n",
        "= \(M)\(O)\(N)\(E)\(Y)\n"];
```

SEND+MORE=MONEY问题要求给每一个字母赋不同的数值使得此算术约束满足。 [Listing 2.2.4](https://www.minizinc.org/doc-2.8.3/chi/modelling2.html#ex-smm) 中的模型使用 `alldifferent([S,E,N,D,M,O,R,Y])` 约束表达式来保证每个字母有不同的数字值。

我们可以用以下代替此行

```
include "globals.mzn";
```

它包含了所有的全局约束。

### 条件表达式

MiniZinc提供了一个条件表达式 *if-then-else-endif* 。 它的一个使用例子如下

```
int: r = if y != 0 then x div y else 0 endif;
```

若 `y` 不是零，则 `r` 设为 `x` 除以 `y` ，否则则设为零。

### 布尔型操作

MiniZinc中的布尔型表达式可以按照标准的数学语法来书写。布尔常量是 `真` 或 `假` ，布尔型操作符有合取，即，与 (`/\`) ，析取，即，或 (`\/`) ，必要条件蕴含 (`<-`) ，充分条件蕴含 (`->`) ，充分必要蕴含 (`<->`) 以及非 (`not`)。内建函数 `bool2int` 强制转换布尔型为整型：如果参数为真，它返回1，否则返回0。

## 谓词和函数

MiniZinc中的谓词允许我们用简洁的方法来表达模型中的复杂约束。 MiniZinc中的谓词利用预先定义好的全局约束建模，同时也让建模者 获取以及定义新的复杂约束。MiniZinc中的函数用来捕捉模型中的共同结构。 **实际上，一个谓词就是一个输出类型为 `var bool` 的函数。**

### 全局约束

#### alldifferent

略，上有

#### Cumulative

约束 `cumulative` 被用来描述资源累积使用情况。

```
cumulative(array[int] of var int: s, array[int] of var int: d,
           array[int] of var int: r, var int: b)
```

规定对于一个起始时间为 `s` ，持续时间为 `d` 以及资源需求量为 `r` 的任务集合，在任何时间对资源的需求量都不能超过一个全局资源量界限 `b` 。

#### Table

约束 `table` 强制变量元组从一个元组集合中取值。由于MiniZinc中没有元组，我们用数组来描述它。 根据元组是布尔型还是整型， `table` 的使用有以下两种格式

```
table(array[int] of var bool: x, array[int, int] of bool: t)
table(array[int] of var int:  x, array[int, int] of int:  t)
```

强制约束了 x∈t ，其中 x 和 t 中的每一行是元组， t 是一个元组集合。

#### Regular

### 定义谓词

使用以下形式的语句，我们可以定义谓词

```
predicate <谓词名> ( <参数定义>, ..., <参数定义> ) = <布尔表达式>
```

`<谓词名>` 必须是一个合法的MiniZinc标识符，每个 `<参数定义>` 都是一个合法的MiniZinc类型 type 声明。

参数 定义的一个松弛是数组的索引类型可以是 没有限制地 写为 `int` 。

```
predicate no_overlap(var int:s1, int:d1, var int:s2, int:d2) =
    s1 + d1 <= s2 \/ s2 + d2 <= s1;
```

它定义了一个新的约束用来约束起始时间为 `s1` ，持续时间为 `d1` 的任务不能和起始时间为 `s2` ，持续时间为 `d2` 的任务重叠。它可以在模型的任何（包含决策变量的） 布尔型表达式 可以出现的地方使用。

### 定义测试

使用以下形式的语句，我们定义测试

```
test <谓词名> ( <参数定义>, ..., <参数定义> ) = <布尔表达式>

test even(int:x) = x mod 2 = 0;
```

其中的 `<布尔表达式>` 必须是固定的。

另外我们介绍一个谓词中使用到的 `assert` 命令的新形式。

```
assert ( <布尔表达式>, <字符串表达式>, <表达式> )
```

`assert` 表达式的类型和最后一个参数的类型一样。 `assert` 表达式检测第一个参数是否为假，如果是则输出第二个参数字符串。如果第一个参数是真，则输出第三个参数。

### 定义函数

函数用以下格式的语句定义

```
function <返回类型> : <函数名> ( <参数定义>, ..., <参数定义> ) = <表达式>
```

`<函数名>` 必须是一个合法的MiniZinc标识符。每一个 `<参数定义>` 是一个合法的MiniZinc类型声明。 `<返回类型>` 是函数的返回类型，它必须是 `<表达式>` 的类型。参数和谓词定义中的参数有一样的限制。

```
function int: posn(int: a, int: a1) = (a-1) * S + a1;
```

### 局部变量

在谓词，函数或者测试中，引进 *局部变量* 总是非常有用的。 表达式 `let` 允许你去这样做。 它可以被用来引进决策变量 决策变量 和 参数 ，但是参数必须被初始化。 例如：

```
var s..e: x;
let {int: l = s div 2; int: u = e div 2; var l .. u: y;} in x = 2*y
```

局部变量 可以在任何以下格式的emph{let表达式}中引入：

```
let { <声明>; ... <声明> ; } in <表达式>
```

**注意局部变量和约束不可以出现在测试中。局部变量不可以出现在 否定 或者 混合 语境下的谓词和函数中，除非这个变量是用表达式定义的。**

### 局部约束

Let表达式也可以被用来引入局部约束，通常用来约束局部变量的行为。 例如，考虑只利用乘法来定义开根号函数：

```
function var float: mysqrt(var float:x) =
         let { var float: y;
               constraint y >= 0;
               constraint x = y * y; } in y;
```

局部约束确保了 `y` 取正确的值；而此值则会被函数返回。

**局部约束可以在let表达式中使用，尽管最普遍的应用是在定义函数时。**

### 选项类型

选项类型是一个强大的抽象，使得简洁建模成为可能。一个选项类型决策变量代表了一个有其他可能 ⊤ 的变量，在MiniZinc中表达为 `<>` ，代表了这个变量是 *缺失的* 。**选项类型变量在建模一个包含在其他变量没做决定之前不会有意义的变量的问题**时是很有用的。

一个选项类型变量被声明为：

```
var opt <类型> : <变量名>:
```

其中 `<类型>` 是 `int` ， `float` 或 `bool` 中的一个，或者是一个固定范围的表达式。选项类型变量可以是参数，但是这个不常用。

一个选项类型变量可以有附加值 `<>` 表明它是 *缺失的* 。

三个内建函数被提供给选项类型变量： `absent(v)` 只有在选项类型变量 `v` 取值 `<>` 时返回 `true` ， `occurs(v)` 只有在选项类型变量 `v` *不* 取值 `<>` 时返回 `true` ， 以及 `<>` 返回 `v` 的正常值或者当它取值 `<>` 时返回失败。