# 苍穹外卖

## 项目简介

项目所用技术

![PixPin_2024-03-27_16-24-24](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/PixPin_2024-03-27_16-24-24.png)

项目功能模块

![PixPin_2024-03-27_16-08-20](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/PixPin_2024-03-27_16-08-20.png)

后端

![PixPin_2024-03-27_16-37-29](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/PixPin_2024-03-27_16-37-29.png)

![image-20240327165429906](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240327165429906.png)

![PixPin_2024-03-27_16-40-16](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/PixPin_2024-03-27_16-40-16.png)

![PixPin_2024-03-27_16-42-34](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/PixPin_2024-03-27_16-42-34.png)

## 数据库搭建

![image-20240327171429336](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240327171429336.png)

## 基础代码

管理端发出请求，统一使用 /admin 作为前缀

用户端发出请求，统一使用 /user 作为前缀

### 登录逻辑

前端点击登录，请求`http://localhost/api/employee/login`

进入controller

```java
/**
 * 员工管理
 */
@RestController
@RequestMapping("/admin/employee")
@Slf4j //lombok的注解，之后就可以用 log.xxx 来输出日志了
public class EmployeeController {

    @Autowired
    private EmployeeService employeeService;
    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 登录
     *
     * @param employeeLoginDTO
     * @return
     */
    @PostMapping("/login")
    public Result<EmployeeLoginVO> login(@RequestBody EmployeeLoginDTO employeeLoginDTO) {
        log.info("员工登录：{}", employeeLoginDTO);

        Employee employee = employeeService.login(employeeLoginDTO);

        //登录成功后，生成jwt令牌 通过登录的员工id以及配置文件中的私钥和过期时间生成token
        Map<String, Object> claims = new HashMap<>();
        claims.put(JwtClaimsConstant.EMP_ID, employee.getId());
        String token = JwtUtil.createJWT(
                jwtProperties.getAdminSecretKey(),
                jwtProperties.getAdminTtl(),
                claims);

        //在vo上标识注解 @Builder 从而生成静态内部类 从而可以用以下模式构建一个对象
        //而不是像之前new之后一个个set
        EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
                .id(employee.getId())
                .userName(employee.getUsername())
                .name(employee.getName())
                .token(token)
                .build();

        return Result.success(employeeLoginVO);
    }

}
```

首先，这个类注入了两个对象 `employeeService` 和 `jwtProperties`

当请求后，login方法得到前端传输过来的 DTO 对象，employeeService 调用login方法进行检查

```java
public Employee login(EmployeeLoginDTO employeeLoginDTO) {
    String username = employeeLoginDTO.getUsername();
    String password = employeeLoginDTO.getPassword();

    //1、根据用户名查询数据库中的数据
    Employee employee = employeeMapper.getByUsername(username);

    //2、处理各种异常情况（用户名不存在、密码不对、账号被锁定）
    if (employee == null) {
        //账号不存在
        throw new AccountNotFoundException(MessageConstant.ACCOUNT_NOT_FOUND);
    }

    //密码比对
    // TODO 后期需要进行md5加密，然后再进行比对
    if (!password.equals(employee.getPassword())) {
        //密码错误
        throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR);
    }

    if (employee.getStatus() == StatusConstant.DISABLE) {
        //账号被锁定
        throw new AccountLockedException(MessageConstant.ACCOUNT_LOCKED);
    }

    //3、返回实体对象
    return employee;
}
```

在service层的方法中，首先根据 employeeLoginDTO 得到其姓名和密码，然后根据用户名查询数据库中真正实体类 Employee 的信息。进行判断后，若成功返回这个实体类对象

登录成功后，生成jwt令牌 通过登录的员工id以及配置文件中的私钥和过期时间生成token

```java
Map<String, Object> claims = new HashMap<>();
claims.put(JwtClaimsConstant.EMP_ID, employee.getId());
String token = JwtUtil.createJWT(
    jwtProperties.getAdminSecretKey(),//配置文件中配置的，将jwtProperties注为配置类
    jwtProperties.getAdminTtl(),//然后和配置文件绑定注入值
    claims);
```

生成完token之后，构建返回给前端的 vo 对象

```java
//在vo上标识注解 @Builder 从而生成静态内部类 从而可以用以下模式构建一个对象
//而不是像之前new之后一个个set
EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
    .id(employee.getId())
    .userName(employee.getUsername())
    .name(employee.getName())
    .token(token)
    .build();
```

最后return回去

```java
return Result.success(employeeLoginVO);
```

注意一下这个Result类

```java
@Data
public class Result<T> implements Serializable {

    private Integer code; //编码：1成功，0和其它数字为失败
    private String msg; //错误信息
    private T data; //数据

    public static <T> Result<T> success() {
        Result<T> result = new Result<T>();
        result.code = 1;
        return result;
    }

    public static <T> Result<T> success(T object) {
        Result<T> result = new Result<T>();
        result.data = object;//当传入有值时，将值赋给data字段
        result.code = 1;
        return result;
    }

    public static <T> Result<T> error(String msg) {
        Result result = new Result();
        result.msg = msg;//当传入无值时，但有字符串时，将字符串赋给msg字段
        result.code = 0;
        return result;
    }

}
```

#### 小问题 请求地址

前端请求的地址是 `http://localhost/api/employee/login`

后端实际地址是` http://localhost:8080/admin/employee/login`

这是由于 nginx 转发了请求

```conf
# 反向代理,处理管理端发送的请求
listen:80
server_name localhost;


location /api/ { 
    proxy_pass   http://localhost:8080/admin/;
}
```

![image-20240328133335623](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240328133335623.png)

#### 小问题二 密码加密

现在数据库所存的密码是未加密的，不安全，我们需要将密码加密后存储，比对时，通过将获得的密码加密后与数据库已加密的密文比对即可。

第一步修改数据库中的密码为 e10adc3949ba59abbe56e057f20f883e

第二步，判断密码是否相等时先加密再处理

```java
// 进行md5加密，然后再进行比对 DigestUtils是自带的工具类
password=DigestUtils.md5DigestAsHex(password.getBytes());
```

### 接口文档 swagger

首先将所给 json 文档导入至 apifox中

> 这是设计阶段使用的工具
>
> 下面是开发时的测试

[K](https://doc.xiaominfo.com/)[nife4j](https://doc.xiaominfo.com/)[ ](https://doc.xiaominfo.com/)是为Java MVC框架集成Swagger生成Api文档的增强解决方案。

导入依赖

```xml
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-spring-boot-starter</artifactId>
    <version>3.0.2</version>
</dependency>
```

然后在config类中进行配置

```java
@Bean
public Docket docket() {
    ApiInfo apiInfo = new ApiInfoBuilder()
        .title("苍穹外卖项目接口文档")
        .version("2.0")
        .description("苍穹外卖项目接口文档")
        .build();
    Docket docket = new Docket(DocumentationType.SWAGGER_2)
        .apiInfo(apiInfo)
        .select()
        .apis(RequestHandlerSelectors.basePackage("com.sky.controller"))
        .paths(PathSelectors.any())
        .build();
    return docket;
}

/**
     * 设置静态资源映射
     * @param registry
     */
protected void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
    registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
}
```

## 员工管理

![image-20240328144917057](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240328144917057.png)

### 新增员工

![image-20240328144108590](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240328144108590.png)

三个需求：

* 账号必须唯一
* 手机号为合法的11位手机号码
* 身份证号为合法的18位身份证号码

注意密码是默认的 123456

请求和响应参数

```json
{
  "id": 0,//非必须
  "idNumber": "string",
  "name": "string",
  "phone": "string",
  "sex": "string",
  "username": "string"
}

{
  "code": 0, //1为成功 0为失败
  "data": {},
  "msg": "string"
}
```

设置对应 DTO (sky-pojo中)即前端提交过来的数据模型

```java
@Data
public class EmployeeDTO implements Serializable {

    private Long id;

    private String username;

    private String name;

    private String phone;

    private String sex;

    private String idNumber;

}
```

测试的时候需要前端的token，发一次登录请求就可以获取到token，添加至swagger文档全局参数中即可，就不会因为没有token而无法测试。

controller

```java
@PostMapping
@ApiOperation("新增员工")
public Result<String> add(@RequestBody EmployeeDTO employeeDTO) {
    log.info("新增员工：{}", employeeDTO);
    employeeService.add(employeeDTO);
    return Result.success();
}
```

ServiceImpl

```java
@Override
public void add(EmployeeDTO employeeDTO) {
    //首先DTO转换为Entity
    Employee employee = new Employee();

    //使用BeanUtils中的方法快捷复制属性给employee
    //第一个为源数据 第二个为目标数据
    BeanUtils.copyProperties(employeeDTO,employee);

    //完善employee类其它属性 状态 密码 创建时间/修改时间 创建人/修改人
    employee.setStatus(StatusConstant.ENABLE);
    employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));
    employee.setCreateTime(LocalDateTime.now());
    employee.setUpdateTime(LocalDateTime.now());
    // TODO 这里写死了 之后修改
    employee.setCreateUser(10L);
    employee.setUpdateUser(10L);


    int i = employeeMapper.addEmployee(employee);//这里应该需要判断是否插入成功 不需要，若失败，会抛异常 处理异常即可
}
```

mapper

```java
@Insert("INSERT INTO employee(username,name,password,phone,sex,id_number,status,create_time,update_time,create_user,update_user)" +
            " VALUES(#{username},#{name},#{password},#{phone},#{sex},#{idNumber},#{status},#{createTime},#{updateTime},#{createUser},#{updateUser})")
    int addEmployee(Employee employee);
```

两个问题

* 用户名需要唯一，不唯一会抛异常  java.sql.SQLIntegrityConstraintViolationException
  * **在全局异常类中加入该异常的捕获**

* 创建用户人和修改用户人写死了，需要修改
  * **每一次请求都是一个单独线程，ThreadLocal为每一个线程提供单独一份存储空间，具有线程隔离的效果。将jwt解析出来的id存储在ThreadLocal中**

ThreadLocal常用方法：

* public void set(T value)  设置当前线程的线程局部变量的值    存值

* public T get()  返回当前线程所对应的线程局部变量的值  取值

* public void remove()    移除当前线程的线程局部变量  删除值

**handler/GlobalExceptionHandler 解决用户名问题**

```java
@ExceptionHandler //通过使用 @ExceptionHandler 注解，可以将方法标记为用于处理特定异常类型的处理器方法。
public Result exceptionHandler(SQLIntegrityConstraintViolationException ex){
    //Duplicate entry 'zhangsan' for key 'employee.idx_username' 异常信息
    String message=ex.getMessage();
    if(message.contains("Duplicate entry")){
        String[] split = message.split(" ");//用空格分割 提取用户名
        String msg=split[2]+"已存在";
        return Result.error(msg);
    }
    return Result.error(MessageConstant.UNKNOWN_ERROR);
}
```

**创建人和修改人问题**

Interceptor/JwtTokenAdminInterceptor

```java
//2、校验令牌
try {
    log.info("jwt校验:{}", token);
    Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
    Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
+    BaseContext.setCurrentId(empId);//BaseContext封装了ThreadLocal类相关方法
    log.info("当前员工id：", empId);
    //3、通过，放行
    return true;
} catch (Exception ex) {
    //4、不通过，响应401状态码
    response.setStatus(401);
    return false;
}
```

### 员工分页查询

业务规则：

- 根据页码展示员工信息
- 每页展示10条数据
- 分页查询时可以根据需要，输入员工姓名进行查询

前后端示例

```json
{
    name //不是必须
	page //必须 第几页
	pageSize //必须 每页多少条
}

{
  "code": 0,
  "msg": null,
  "data": {
    "total": 0,//一共多少
    "records": [//每一个查询结果
      {
        "id": 0,
        "username": "string",
        "name": "string",
        "password": "string",
        "phone": "string",
        "sex": "string",
        "idNumber": "string",
        "status": 0,
        "createTime": "string",
        "updateTime": "string",
        "createUser": 0,
        "updateUser": 0
      }
    ]
  }
}
```

#### controller

```java
@GetMapping("/page")
@ApiOperation("分页查询员工") //@ModelAttribute 将query方式传递过来的参数绑定到类上，不加也没事，会自动帮我们绑定
public Result<PageResult> page(@ModelAttribute EmployeePageQueryDTO employeePageQueryDTO) {
    log.info("分页查询员工：{}", employeePageQueryDTO);
    PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);
    return Result.success(pageResult);
}
```

#### service

```java
PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
```

```java
@Override
public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) {
    //使用分页插件 pageHelper完成
    PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());
    Page<Employee> employees = employeeMapper.pageQuery(employeePageQueryDTO);
    return new PageResult(employees.getTotal(),employees.getResult());
}
```

#### mapper

```java
Page<Employee> pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
```

```xml
<select id="pageQuery" resultType="com.sky.entity.Employee">
    select * from employee
    <where>
        <if test="name!=null and name!=''">
            and name like concat('%',#{name},'%')
        </if>
    </where>
    order by create_time DESC
</select>
```

注意这里使用了动态sql，并且采用模糊查询的方式，得到的结果降序，因为肯定得先显示最后创建的

#### 功能完善

测试之后发现时间显示异常

```json
"records": [
      {
        "id": 5,
        "username": "zhangsan2",
        "name": "zhangsan2",
        "password": "e10adc3949ba59abbe56e057f20f883e",
        "phone": "15372090175",
        "sex": "1",
        "idNumber": "111122223333444455",
        "status": 1,
        "createTime": [
          2024,
          3,
          28,
          16,
          13,
          45
        ],
        "updateTime": [
          2024,
          3,
          28,
          16,
          13,
          45
        ],
        "createUser": 1,
        "updateUser": 1
      },
```

**这是由于未规定时间的json转换格式导致**

* 在属性上加入注解，对日期进行格式化  @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
* 在config文件夹下 webMvcConfiguration类中配置消息转换器，统一对消息进行处理

```java
protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
    log.info("扩展消息转化器");
    //创建一个消息转换器
    MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
    //设置对象转换器 JacksonObjectMapper 自己封装的JacksonObjectMapper
    converter.setObjectMapper(new JacksonObjectMapper());
    //将我们自己设的转换器放入spring中，并且将优先级提至最高
    converters.add(0,converter);
}
```

**注意在测试时若返回401，是token过期了，重新设置再测试即可**

### 启用禁用员工账号

![image-20240329153310553](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240329153310553.png)

#### controller

```java
@PostMapping("/status/{status}")//注意因为一个是路径参数所以需要@PathVariable注解
@ApiOperation("修改员工状态") //注意因为这个请求不是查询，所以无需指定Result的泛型
public Result statusStartOrStop(@PathVariable Integer status,Long id) {
    log.info("修改员工状态：{} {}", status,id);
    employeeService.statusStartOrStop(id,status);
    return Result.success();
}
```

#### service

```java
void statusStartOrStop(Long id, Integer status);
```

```java
@Override
public void statusStartOrStop(Long id, Integer status) {
    //考虑代码的复用，一个单表的更新操作应该使用动态sql完成
    Employee employee = Employee.builder()
        .status(status)
        .id(id)
        .build();
    employeeMapper.update(employee);
}
```

#### mapper

```java
void update(Employee employee);
```

```xml
<update id="update" parameterType="employee">
    update employee
    <set>
        <if test="username != null">username=#{username},</if>
        <if test="password != null">password=#{password},</if>
        <if test="name != null">name=#{name},</if>
        <if test="phone != null">phone=#{phone},</if>
        <if test="sex != null">sex=#{sex},</if>
        <if test="idNumber != null">id_number=#{idNumber},</if>
        <if test="status != null">status=#{status},</if>
        <if test="createTime != null">create_time=#{createTime},</if>
        <if test="updateTime != null">update_time=#{updateTime}</if>
        <if test="createUser != null">create_user=#{createUser},</if>
        <if test="updateUser != null">update_user=#{updateUser}</if>
    </set>
    where  id=#{id}
</update>
```

### 编辑员工

前端

```json
//查询为路径参数

{ //编辑
  "id": 0,
  "idNumber": "string",
  "name": "string",//账号
  "phone": "string",
  "sex": "string",
  "username": "string"//姓名
}
```

如果要编辑员工信息，首先要查询员工，然后编辑，所以有两个接口

#### controller

```java
@GetMapping("/{id}")
@ApiOperation("根据id查询员工")
public Result<Employee> getById(@PathVariable Long id) {
    log.info("根据id查询员工：{}", id);
    Employee employee = employeeService.getById(id);
    return Result.success(employee);
}

@PutMapping
@ApiOperation("编辑员工信息")
public Result editEmployee(@RequestBody EmployeeDTO employeeDTO) {
    log.info("编辑员工信息：{}", employeeDTO);
    employeeService.editEmployee(employeeDTO);
    return Result.success();
}
```

#### service

```java
Employee getById(Long id);

void editEmployee(EmployeeDTO employeeDTO);
```

```java
@Override
public Employee getById(Long id) {
    Employee employee = employeeMapper.getById(id);
    //将密码设置为null，提高安全性
    employee.setPassword(null);
    return employee;
}

@Override
public void editEmployee(EmployeeDTO employeeDTO) {
    Employee employee = new Employee();
    BeanUtils.copyProperties(employeeDTO,employee);
    employeeMapper.update(employee);
}
```

#### mapper

```java
void update(Employee employee);

    /**
     * 根据id查用户信息
     * @param id 
     * @return
     */
@Select("select * from employee where id=#{id}")
Employee getById(Long id);
```

## 分类管理

### 新增菜品/套餐分类

前端参数

```java
{
  "id": 0,
  "name": "string",
  "sort": 0,
  "type": 0
}
```

菜品和套餐通过type区分，只需要请求一个接口即可

#### controller

```java
@RestController
@Api(tags = "分类管理接口")
@Slf4j
@RequestMapping("/admin/category")
public class CategoryController {
    @Autowired
    private CategoryService categoryService;

    @PostMapping
    @ApiOperation(value = "添加分类")
    public Result addCategory(@RequestBody CategoryDTO categoryDTO){
        log.info("添加分类:{}",categoryDTO);
        categoryService.addCategory(categoryDTO);
        return Result.success();
    }
}
```

#### service

```java
public interface CategoryService {
    /**
     * 添加分类
     * @param categoryDTO
     */
    void addCategory(CategoryDTO categoryDTO);
}
```

```java
@Service
public class CategoryServiceImpl implements CategoryService {
    @Autowired
    private CategoryMapper categoryMapper;
    /**
     * 添加分类
     * @param categoryDTO
     */
    @Override
    public void addCategory(CategoryDTO categoryDTO) {
        Category category = new Category();
        BeanUtils.copyProperties(categoryDTO, category);
        //DTO只有 id name type sort ，没有 status createTime updateTime createUser updateUser
        //注意分类默认应禁用 StatusConstant.DISABLE=0
        category.setStatus(StatusConstant.DISABLE);
        category.setCreateTime(LocalDateTime.now());
        category.setUpdateTime(LocalDateTime.now());
        category.setCreateUser(BaseContext.getCurrentId());
        category.setUpdateUser(BaseContext.getCurrentId());
        //注意add方法应该可以复用，因为添加套餐和添加分类只是type的区别
        categoryMapper.add(category);
    }
}
```

#### mapper

```java
@Mapper
public interface CategoryMapper {

    /**
     * 添加套餐或者分类
     * @param category
     */
    void add(Category category);
}

```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.sky.mapper.CategoryMapper">
    <insert id="add" parameterType="category">
        insert into category (type,name,sort,status,create_time,update_time,create_user,update_user)
        values (#{type},#{name},#{sort},#{status},#{createTime},#{updateTime},#{createUser},#{updateUser})
    </insert>
</mapper>
```

### 分页查询

![image-20240329182453953](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240329182453953.png)

query类型参数

#### controller

```java
@GetMapping("/page")
@ApiOperation(value = "分页查询")
public Result<PageResult> page(@ModelAttribute CategoryPageQueryDTO categoryPageQueryDTO){
    log.info("分页查询：{}",categoryPageQueryDTO);
    PageResult pageResult=categoryService.pageQuery(categoryPageQueryDTO);
    return Result.success(pageResult);
}
```

#### service

```java
/**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);
```

```java
/**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
@Override
public PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO) {
    //使用PageHelper帮助我们查询
    PageHelper.startPage(categoryPageQueryDTO.getPage(), categoryPageQueryDTO.getPageSize());
    Page<Category> page=categoryMapper.pageQuery(categoryPageQueryDTO);
    return new PageResult(page.getTotal(),page.getResult());
}
```

#### mapper

```java
/**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
Page<Category> pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);
```

```xml
<select id="pageQuery" parameterType="category" resultType="category">
    select * from category
    <where>
        <if test="type != null">
            and type=#{type}
        </if>
        <if test="name != null">
            and name like concat('%',#{name},'%')
        </if>
    </where>
    order by sort asc
</select>
```

### 修改分类

前端参数

```json
{
  "id": 0,
  "name": "string",
  "sort": 0,
  "type": 0
}
```

#### controller

```java
@PutMapping
@ApiOperation(value = "编辑分类")
public Result editCategory(@RequestBody CategoryDTO categoryDTO){
    log.info("编辑分类：{}",categoryDTO);
    categoryService.editCategory(categoryDTO);
    return Result.success();
}
```

#### service

```java
/**
     * @param categoryDTO
     */
void editCategory(CategoryDTO categoryDTO);
```

```java
@Override
public void editCategory(CategoryDTO categoryDTO) {
    //修改的代码页应该重用
    Category category = new Category();
    BeanUtils.copyProperties(categoryDTO, category);
    //注意设置修改时间和修改人
    category.setUpdateTime(LocalDateTime.now());
    category.setUpdateUser(BaseContext.getCurrentId());
    categoryMapper.update(category);
}
```

#### mapper

```java
/**
     * 更新分类
     * @param category
     */
void update(Category category);
```

```xml
<update id="update" parameterType="category">
    update category
    <set>
        <if test="type != null"> type = #{type},</if>
        <if test="name != null"> name = #{name}, </if>
        <if test="sort != null"> sort = #{sort},</if>
        <if test="status != null"> status = #{status},</if>
        <if test="updateTime != null"> update_time = #{updateTime}, </if>
        <if test="updateUser != null"> update_user = #{updateUser}, </if>
    </set>
    where id = #{id}
</update>
```

### 启用禁用分类/套餐

一个路径参数 status 一个query参数 id

#### controller

```java
@PostMapping("/status/{status}")
@ApiOperation(value = "修改分类状态") // http://localhost/api/category/status/1?id=23 使用@RequestParam显式的取id
public Result status(@PathVariable("status") Integer status, @RequestParam("id") Long id){
    log.info("修改分类状态：{}",id);
    categoryService.editStatus(status,id);
    return Result.success();
}
```

#### service

```java
/**
     * 修改分类状态
     * @param status
     * @param id
     */
void editStatus(Integer status, Long id);
```

```java
@Override
public void editStatus(Integer status, Long id) {
    Category category=Category.builder()
        .status(status)
        .id(id)
        .build();
    categoryMapper.update(category);
}
```

#### mapper

和修改分类共用代码

### 根据类型查询分类

前端  query参数type

**注意此处查看所给代码发现要求查询的分类不为禁用状态，且结果需排序**

```json
示例
{
  "code": 0,
  "data": [ //后端需要返回数组
    {
      "createTime": "2019-08-24T14:15:22Z",
      "createUser": 0,
      "id": 0,
      "name": "string",
      "sort": 0,
      "status": 0,
      "type": 0,
      "updateTime": "2019-08-24T14:15:22Z",
      "updateUser": 0
    }
  ],
  "msg": "string"
}
```

#### controller

```java
@GetMapping("/list")
@ApiOperation(value = "根据类型查询分类")
public Result<List<Category>> getCategoryByType(@RequestParam("type") Integer type){
    log.info("根据类型查询分类：{}",type);
    List<Category> list=categoryService.getCategoryByType(type);
    return Result.success(list);
}
```

#### service

```java
/**
     * 根据类型查询
     * @param type
     * @return
     */
List<Category> getCategoryByType(Integer type);
```

```java
@Override
public List<Category> getCategoryByType(Integer type) {
    List<Category> categoryList = categoryMapper.getCategoryByType(type);
    return categoryList;
}
```

#### mapper

```java
/**
     * 根据类型查询分类
     * @param type
     * @return
     */
List<Category> getCategoryByType(Integer type);
```

```xml
<select id="getCategoryByType" resultType="category">
    select * from category
    where status =1
    <if test="type!=null">
        and type=#{type}
    </if>
    order by sort asc , create_time desc
</select>
```

### 根据id删除分类

前端传递一个query参数

后端需要考虑两个问题

* 当前分类下若有菜品不可以删除，需要抛出异常
* 当前分类关联了套餐不可以删除，需要抛出异常

#### controller

```java
@DeleteMapping
@ApiOperation(value = "删除分类")
public Result deleteById(@RequestParam("id") Long id){
    log.info("删除分类：{}",id);
    categoryService.deleteById(id);
    return Result.success();
}
```

#### service

```java
/**
     * 根据id删除分类
     * @param id
     */
void deleteById(Long id);
```

```java
@Override
public void deleteById(Long id) {
    //注意需要考虑当前分类下有无菜品
    Integer i = dishMapper.countByCategoryId(id);
    if(i>0){//若有菜品，抛出当前分类下有菜品异常 终止删除
        throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_DISH);
    }
    i= setmealMapper.countByCategoryId(id);
    if(i>0){//若有套餐，抛出当前分类下关联了套餐异常 终止删除
        throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);
    }
    categoryMapper.deleteById(id);
}
```

#### mapper

```java
/**
     * 根据id删除分类
     * @param id
     */
@Delete("delete from category where id = #{id}")
void deleteById(Long id);
```

DishMapper

```java
@Select("select count(id) from dish where category_id = #{categoryId}")
Integer countByCategoryId(Long categoryId);
```

SetMapper

```java
/**
     * 根据分类id查找套餐数量
     * @param categoryId
     * @return
     */
@Select("select count(id) from setmeal where category_id = #{categoryId}")
Integer countByCategoryId(Long categoryId);
```

## 菜品管理

### 公共字段自动填充

业务中有很多公共字段需要我们填充，比如创建时间、修改时间、创建人、修改人。

每次我们操作的时候总是需要手动填充，这样会产生大量的代码冗余，而且后期也不好维护，如何让其自动填充呢？

**考虑使用AOP的注解实现**

- 自定义注解 AutoFill，用于标识需要进行公共字段自动填充的方法
- 自定义切面类 AutoFillAspect，统一拦截加入了 AutoFill 注解的方法，通过反射为公共字段赋值
- 在 Mapper 的方法上加入 AutoFill 注解

注意创建时，即 add，和修改时即 update

#### 自定义注解

annotation/AutoFIll

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AutoFIll {

    /**
     * 数据库操作类型 update insert
     * @return
     */
    OperationType value();
}
```

#### 注解实现切面

注意此处需要导包

```xml
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjrt</artifactId>
    <version>1.9.4</version>
</dependency>

<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.4</version>
</dependency>
```

```java
@Component
@Aspect
@Slf4j
public class AutoFillAspect {

    //切入点 即在哪切入 包 类 方法 方法参数
    @Pointcut("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFIll)")
    public void autoFillPointCut(){}


    //连接点 具体切入的实现
    @Before("autoFillPointCut()")
    public void autoFill(JoinPoint joinPoint) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        log.info("公共字段自动填充数据");
        // 获取到当前被拦截方法上的数据库操作类型
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        AutoFIll annotation = signature.getMethod().getAnnotation(AutoFIll.class);//获得方法上的注解
        OperationType value = annotation.value();//获得方法上的value值

        //获取到当前被拦截方法的参数--实体对象
        Object[] args = joinPoint.getArgs();//方法的参数，约定第一个参数为实体类
        if(args==null || args.length==0){//加一层判断保护
            return;
        }
        Object obj = args[0];//获得实体类

        //准备赋值的数据
        LocalDateTime now = LocalDateTime.now();
        Long currentId = BaseContext.getCurrentId();

        //根据当前不同的操作类型，为对应的属性通过反射来赋值
        if(value==OperationType.INSERT){
            //插入新的，需要给四个字段赋值 通过反射传递方法名和参数类型获得方法 然后 方法名.invoke(obj,值)
            Method setCreateTime = obj.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
            Method setUpdateTime = obj.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
            Method setCreateUser = obj.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);
            Method setUpdateUser = obj.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);

            setCreateTime.invoke(obj,now);
            setUpdateTime.invoke(obj,now);
            setCreateUser.invoke(obj,currentId);
            setUpdateUser.invoke(obj,currentId);
        }else{
            //更新 需要给两个字段赋值
            Method setUpdateTime = obj.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
            Method setUpdateUser = obj.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);

            setUpdateTime.invoke(obj,now);
            setUpdateUser.invoke(obj,currentId);
        }
    }

}
```

#### 在Mapper方法上加上注解

CategoryMapper

```java
@AutoFIll(value = OperationType.INSERT)
void insert(Category category);

@AutoFIll(value = OperationType.UPDATE)
void update(Category category);
```

EmployeeMapper

```java
@Insert("INSERT INTO employee(username,name,password,phone,sex,id_number,status,create_time,update_time,create_user,update_user)" +
        " VALUES(#{username},#{name},#{password},#{phone},#{sex},#{idNumber},#{status},#{createTime},#{updateTime},#{createUser},#{updateUser})")
@AutoFIll(value = OperationType.INSERT)
int insert(Employee employee);
```

```java
@AutoFIll(value = OperationType.UPDATE)
void update(Employee employee);
```

#### 总结

`JoinPoint` 是 Spring AOP 框架中的一个核心类，用于表示连接点（Join Point）。连接点是程序执行过程中可以插入切面的点，通常是方法的调用或异常抛出事件。

在 Spring AOP 中，切面可以定义一系列通知（Advice），并将它们织入到连接点中，以实现对目标方法的增强。连接点提供了一种让切面与目标方法进行交互的机制，使得切面可以获取方法参数、修改方法的执行结果、捕获方法执行时的异常等。

`JoinPoint` 类主要提供了以下方法：

1. `getArgs()`：获取连接点方法的参数数组。
2. `getSignature()`：获取连接点方法的签名，即方法的描述信息。
3. `getTarget()`：获取连接点目标对象。
4. `getThis()`：获取代理对象本身。
5. `toLongString()`：获取连接点的长字符串表示形式。
6. `toShortString()`：获取连接点的短字符串表示形式。

### 新增菜品

![image-20240331175612932](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240331175612932.png)

三个接口

* 根据类型查询分类 已完成

* 文件上传  `/admin/common/upload`

  * ```json
    {
      "code": 0,
      "data": "string",//注意此处必须，即为上传到阿里云后的地址
      "msg": "string"
    }
    ```

* 新增菜品 `/admin/dish`


#### 文件上传 本地

因为课件使用阿里云oss去完成上传文件的任务，但我并没有学过这一块，故采用本地的方式去实现

```java
@RestController
@RequestMapping("/admin/common")
@Api(tags = "通用接口")
@Slf4j
public class CommonController {

    @PostMapping("/upload")
    @ApiOperation("文件上传")
    public Result<String> upload(MultipartFile file) {
        log.info("文件上传:{}", file);
        //文件上传功能实现
        //获得文件上传的真实地址
        String realPath = this.getClass().getClassLoader().getResource("").getPath();
        File localFile = new File(realPath);//创建文件地址
        try {
            String originalFilename = UUID.randomUUID().toString()+
     file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf("."));
            file.transferTo(new File(localFile+"/"+originalFilename));//上传
            return Result.success("http://localhost:8080/admin/common/file/"+originalFilename);
        } catch (IOException e) {
            log.info("文件上传失败:{}", e);
            return Result.error("文件上传失败");
        }
    }
    @GetMapping("/file/{fileName}")
    @ApiOperation("图片获取")
    public byte[] getFile(@PathVariable String fileName) throws IOException {
        String filePath="D:/ProjectTrain/cangqiongwaimai/BackEnd/sky-take-out/sky-server/target/classes/"+fileName;
        Path path = Paths.get(filePath);
        return Files.readAllBytes(path);
    }

}
```

关键代码

```java
String realPath = this.getClass().getClassLoader().getResource("").getPath();
```

这将获得 resources 目录的真实物理地址

**然后使用spring提供的 `transferTo` 方法就可以快捷将上传的文件内容保存到指定的目标文件中**

```java
file.transferTo(new File(localFile+"/"+originalFilename));
```

就可以完成上传了

上传之后需要访问该图片，前端需要一个回显。

- 我们这里采用 硬编码 的形式获得文件物理路径，
- 然后通过使用 `Paths.get()` 方法将文件路径字符串转换为 `java.nio.file.Path` 对象，
- 最后调用 `Files.readAllBytes()` 方法，将 `Path` 对象传递给它。这个方法会读取指定路径的文件内容，并将其作为字节数组返回。

**注意这里仍旧存在一个问题，那就是项目中设置了拦截器，每次对于controller的访问都会进行jwt校验**，因为原来的前端是访问阿里云，所以无需token，而用本地的方法需要token，可以在webmvc配置中放行该访问

```java
registry.addInterceptor(jwtTokenAdminInterceptor)
                .addPathPatterns("/admin/**")
                .excludePathPatterns("/admin/employee/login")
                .excludePathPatterns("/admin/common/file/**");
```

#### 文件上传 代码缩减

实际上如果不上传到 resources 目录下，我们可以直接指定文件路径

`file.transferTo(new File("D:\\uploadFile"+"\\"+originalFilename));`

```java
@RestController
@RequestMapping("/admin/common")
@Api(tags = "通用接口")
@Slf4j
public class CommonController {

    @PostMapping("/upload")
    @ApiOperation("文件上传")
    public Result<String> upload(MultipartFile file) {
        log.info("文件上传:{}", file);
        try {
            String originalFilename = UUID.randomUUID()
                    .toString()+
                    file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf("."));
            file.transferTo(new File("D:\\uploadFile"+"\\"+originalFilename));//上传
            return Result.success("http://localhost:8080/admin/common/file/"+originalFilename);
        } catch (IOException e) {
            log.info("文件上传失败:{}", e);
            return Result.error("文件上传失败");
        }
    }
    @GetMapping("/file/{fileName}")
    @ApiOperation("图片获取")
    public byte[] getFile(@PathVariable String fileName) throws IOException {
        String filePath="D:\\uploadFile\\"+fileName;
        Path path = Paths.get(filePath);
        return Files.readAllBytes(path);
    }
}
```

#### 文件上传 阿里云

首先在配置文件中配置阿里云相关参数

application.yml

```yml
sky:
  jwt:
    # 设置jwt签名加密时使用的秘钥
    admin-secret-key: itcast
    # 设置jwt过期时间
    admin-ttl: 72000000
    # 设置前端传递过来的令牌名称
    admin-token-name: token
  alioss:
    endpoint: ${sky.oss.endpoint}
    access-key-id: ${sky.oss.access-key-id}
    access-key-secret: ${sky.oss.access-key-secret}
    bucket-name: ${sky.oss.bucket-name}
```

application-dev.yml

```yml
sky:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    host: localhost
    port: 3306
    database: sky_take_out
    username: root
    password: 123456
  alioss:
    endpoint: oss-cn-hangzhou.aliyuncs.com
    access-key-id: LTAI5t6ajMtSuWtT9i6mXHS2
    access-key-secret: yGGGPG8vrer1bnuPTQpTo62GKFbxSQ
    bucket-name: web-project-balance
```

因为开发环境生产环境不一定完全相同，所以需要动态加载

因为已经准备了 AliOssUtil 类，这个类就是封装了阿里云上传，而且返回文件在阿里云上的访问路径

也已经准备了 AliOssProperties 类,就是把yml的配置注入

```java
@Component
@ConfigurationProperties(prefix = "sky.alioss")
@Data
public class AliOssProperties {

    private String endpoint;
    private String accessKeyId;
    private String accessKeySecret;
    private String bucketName;

}
```

然后建立一个config配置类，就是用于返回属性注入后的 AliOssUtil 对象

`sky-server com.sky.config`

```java
@Configuration
@Slf4j
public class OssConfiguration {
    
    @Bean
    @ConditionalOnMissingBean //工具类只需要创建一次，不允许重复创建
    public AliOssUtil aliOssUtil(AliOssProperties aliOssProperties){
        return  new AliOssUtil(aliOssProperties.getEndpoint(),
                aliOssProperties.getAccessKeyId(),
                aliOssProperties.getAccessKeySecret(),
                aliOssProperties.getBucketName());
    }
}
```

```java
@RestController
@RequestMapping("/admin/common")
@Api(tags = "通用接口")
@Slf4j
public class CommonController {
    @Autowired
    AliOssUtil aliOssUtil;

    @PostMapping("/upload")
    @ApiOperation("文件上传")
    public Result<String> upload(MultipartFile file){
        log.info("文件上传:{}", file);
        //构造新文件名
        try {
            String extension = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf("."));
            String  upload = aliOssUtil.upload(file.getBytes(), UUID.randomUUID().toString() + extension);
            return Result.success(upload);
        } catch (IOException e) {
            log.error("文件上传失败:{}", e.getMessage());
            return Result.error("文件上传失败");
        }
    }
}
```

#### 新增菜品

发送的参数 封装成一个DTO

```json
{
  "categoryId": 0, //分类id
  "description": "string", //菜品描述
  "flavors": [ //口味对象
    {
      "dishId": 0, //菜品id
      "id": 0, //口味id
      "name": "string", //口味名称
      "value": "string" //口味值
    }
  ],
  "id": 0, //菜品id
  "image": "string", //菜品图片路径
  "name": "string", //菜品名称
  "price": 0, //菜品价格
  "status": 0  //状态默认为禁用
}
```

##### controller

```java
@RestController
@RequestMapping("/admin/dish")
@Api(tags = "菜品管理接口")
@Slf4j
public class DishController {
    @Autowired
    DishService dishService;

    @PostMapping
    @ApiOperation("添加菜品")
    public Result addDish(@RequestBody DishDTO dishDTO){
        log.info("添加菜品:{}",dishDTO);
        dishService.addDishWithFlavor(dishDTO);
        return Result.success();
    }
}
```

##### service

```java
public interface DishService {


    /**
     * 新增菜品以及对应的口味
     * @param dishDTO
     */
    void addDishWithFlavor(DishDTO dishDTO);
}
```

```java
@Service
public class DishServiceImpl implements DishService {
    @Autowired
    DishMapper dishMapper;
    @Autowired
    DishFlavorMapper dishFlavorMapper;

    /**
     * 新增菜品以及对应的口味
     *
     * @param dishDTO
     */
    @Override
    @Transactional //开启事务 因为涉及多个表
    public void addDishWithFlavor(DishDTO dishDTO) {
        //向菜品表插入数据
        Dish dish = new Dish();
        BeanUtils.copyProperties(dishDTO, dish);
        dishMapper.insert(dish);

        //获得回传的id
        Long id = dish.getId();

        //向口味表插入 0 或 多条数据
        //因为口味的数据是封装到一个list中的
        List<DishFlavor> flavors = dishDTO.getFlavors();
        if(flavors != null && !flavors.isEmpty()){
            //设置flavor中的dishId
            flavors.forEach(flavor -> flavor.setDishId(id));
            //批量插入
            dishFlavorMapper.insertBatch(flavors);
        }
    }
}
```

##### mapper

```java
@Mapper
public interface DishMapper {
    /**
     * 根据分类id查找菜品数量
     * @param categoryId
     * @return
     */
    @Select("select count(id) from dish where category_id = #{categoryId}")
    Integer countByCategoryId(Long categoryId);


    @AutoFIll(value = OperationType.INSERT)
    void insert(Dish dish);
}
```

```xml
<mapper namespace="com.sky.mapper.DishMapper">
    
    <insert id="insert" parameterType="com.sky.entity.Dish" useGeneratedKeys="true" keyProperty="id">
        insert into dish (name,category_id, price, image, description,status,create_time,update_time,create_user,update_user)
        values (#{name},#{categoryId},#{price},#{image},#{description},#{status},#{createTime},#{updateTime},#{createUser},#{updateUser})
    </insert>

</mapper>
```

因为还需要插入到dish_flavor表，所以还需一个mapper和mapper.xml

```java
@Mapper
public interface DishFlavorMapper {


    /**
     * 批量插入sql数据
     * @param flavors
     */
    void insertBatch(List<DishFlavor> flavors);
}
```

```xml
<mapper namespace="com.sky.mapper.DishFlavorMapper">
    <insert id="insertBatch" parameterType="java.util.List">
        insert into dish_flavor (dish_id, name, value) values
        <foreach collection="flavors" item="flavor" separator=",">
            (#{flavor.dishId}, #{flavor.name}, #{flavor.value})
        </foreach>
    </insert>
</mapper>
```

##### 总结

菜品插入涉及两张表，并非使用外键进行约束，而是程序中逻辑进行约束。

有几个问题需要注意

* SpringBoot的事务注解，因为多张表，我们希望一个service的操作应该是原子性的，即要么都成功，要么都失败
  * 如何开启事务呢
  * **在需要事务的方法上加  `@Transactional`  在启动类上加 `@EnableTransactionManagement //开启注解方式的事务管理`**

* 批量插入，mybatis中的 `foreach` 标签使用

  * ```xml
    <insert id="insertBatch" parameterType="java.util.List">
        insert into dish_flavor (dish_id, name, value) values
        <foreach collection="flavors" item="flavor" separator=",">
            (#{flavor.dishId}, #{flavor.name}, #{flavor.value})
        </foreach>
    </insert>
    ```

  * 注意 `collection` 即为传入的list集合  `item`为集合中每个元素 `separator`为分隔符，我们知道values后面的值是括号包裹，逗号分割。

* dish_flavor表的每条语句都需要一个 dishId 但是 dish的id在插入之前没有的，这是表自增的值，我们可以在xml的语句中设置

  * ```xml
    <insert id="insert" parameterType="com.sky.entity.Dish" useGeneratedKeys="true" keyProperty="id">
            *******
    </insert>
    ```

  * 具体来说设置 `useGeneratedKeys` 为真， `keyProperty`设为回传的字段，上面表示生成的主键值会设置为 Dish 的 id字段

在 MyBatis 中，`useGeneratedKeys` 属性用于指示**是否要返回由数据库生成的主键值**。通常情况下，当我们向数据库插入一条记录时，如果该表的主键是自增长的（比如 MySQL 中的 AUTO_INCREMENT），数据库会自动生成一个主键值，然后返回给我们。

### 菜品分页查询

业务需求：

* 根据页码展示菜品信息

* 每页展示10条数据

* 分页查询时可以根据需要输入菜品名称、菜品分类、菜品状态进行查询

前后端接口返回值 `/admin/dish/page`

```json
//前端 query查询
page //必需 页码
pageSize //必需 每页记录数
name //非必需 名称
categoryId //非必需 分类id
status //非必需 菜品状态

// 后端
{
  "code": 0,
  "msg": null,
  "data": {
    "total": 0,
    "records": [
      {
        "id": 0,
        "name": "string",
        "categoryId": 0,
        "price": 0,
        "image": "string",
        "description": "string",
        "status": 0,
        "updateTime": "string",
        "categoryName": "string"
      }
    ]
  }
}
```

#### controller

```java
@GetMapping("/page")
    @ApiOperation("分页查询")
    public Result<PageResult> page(DishPageQueryDTO dishPageQueryDTO){
        log.info("分页查询：{}",dishPageQueryDTO);
        PageResult pageResult=dishService.pageQuery(dishPageQueryDTO);
        return Result.success(pageResult);
    }
```

#### service

```java
/**
     * 分页查询菜品
     * @param dishPageQueryDTO
     * @return
     */
    PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO);
```

```java
/**
     * 分页查询菜品
     *
     * @param dishPageQueryDTO
     * @return
     */
@Override
public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) {
    PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());
    Page<DishVO> page=dishMapper.pageQuery(dishPageQueryDTO);
    return new PageResult(page.getTotal(),page.getResult());
}
```

#### mapper

注意应当返回 DishVO 类的数据而非 Dish

此外，此次查询需要使用左外连接，可以看下具体用法

```java
/**
     * 分页查询菜品
     * @param dishPageQueryDTO
     * @return
     */
Page<DishVO> pageQuery(DishPageQueryDTO dishPageQueryDTO);
```

```xml
<select id="pageQuery" parameterType="com.sky.dto.DishPageQueryDTO" resultType="com.sky.vo.DishVO">
    select d.id,d.name,d.price,d.image,d.description,d.status,d.update_time,c.name as categoryName
    from dish d left join category c on d.category_id = c.id
    <where>
        <if test="name != null">
            and d.name like concat('%',#{name},'%')
        </if>
        <if test="categoryId != null">
            and d.category_id = #{categoryId}
        </if>
        <if test="status != null">
            and d.status = #{status}
        </if>
    </where>
</select>
```

### 菜品删除

业务规则：

* 可以一次删除一个菜品，也可以批量删除菜品
* 起售中的菜品不能删除
* 被套餐关联的菜品不能删除
* 删除菜品后，关联的口味数据也需要删除掉

前端 query `/admin/dish`

```json
ids //即 ?ids=1,2,3 这种
//后端
{
  "code": 0,
  "data": "string",
  "msg": "string"
}
```

需要考虑三个表

dish表在执行删除操作时需要考虑当前有无关联套餐表 setmeal_dish ， 而且需要删除 dish_flavor 表相关字段

#### controller

```java
@DeleteMapping
@ApiOperation("删除菜品")
public Result delete(@RequestParam List<Long> ids){
    log.info("删除菜品：{}",ids);
    //注意 ids 其实是字符串，逗号分隔
    //使用@RequestParam注解 Spring 会自动将逗号分隔的参数值解析
    dishService.deleteBatch(ids);
    return Result.success();
}
```

#### service

```java
/**
     * 批量删除菜品
     * @param ids
     */
void deleteBatch(List<Long> ids);
```

```java
/**
     * 批量删除菜品
     *
     * @param ids
     */
//多表联合删除  开启事务  因为涉及多表
@Override
@Transactional
public void deleteBatch(List<Long> ids) {
    //判断菜品能否删除  --status是否为1
    for (Long id : ids) {
        Dish dish=dishMapper.getById(id);
        if(dish.getStatus().equals(StatusConstant.ENABLE)){
            //当前菜品处于起售中，不能删除
            throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);
        }
    }
    //判断菜品能否删除  ---是否被套餐关联
    List<Long> setMealIds = setMealDishMapper.getSetMealIdsByDishId(ids);
    if(setMealIds != null && !setMealIds.isEmpty()){
        throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);
    }
    //删除菜品表中菜品 删除菜品口味表中口味
    for (Long id : ids) {
        dishMapper.deleteById(id);
        dishFlavorMapper.deleteByDishId(id);
    }
}
```

#### mapper

```java
@Select("select * from dish where id=#{id}")
Dish getById(Long id);

@Delete("delete from dish where id=#{id}")
void deleteById(Long id);
```

setMealDishMapper

```java
/**
     * 根据菜品id查套餐id 多对多查询
     * @param ids
     * @return
     */
List<Long> getSetMealIdsByDishId(List<Long> ids);
```

```xml
<select id="getSetMealIdsByDishId" resultType="java.lang.Long">
    select setmeal_id from setmeal_dish where dish_id in
    <foreach collection="ids" item="id" open="(" separator="," close=")">
        #{id}
    </foreach>
</select>
```

### 菜品修改

`/admin/dish`

![image-20240409153534814](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240409153534814.png)

接口设计：

* 根据id查询菜品
* 根据类型查询分类（已实现）
* 文件上传(已实现）
* 修改菜品

#### 根据id查询菜品

`/admin/dish/{id}`

```json
//前端 路径参数

//后端 其实回显的就是 DishDto
{
  "code": 0,
  "data": {
    "categoryId": 0,
    "categoryName": "string",
    "description": "string",
    "flavors": [
      {
        "dishId": 0,
        "id": 0,
        "name": "string",
        "value": "string"
      }
    ],
    "id": 0,
    "image": "string",
    "name": "string",
    "price": 0,
    "status": 0,
    "updateTime": "2019-08-24T14:15:22Z"
  },
  "msg": "string"
}
```

##### controller

```java
@GetMapping("/{id}")
@ApiOperation("查询菜品")
public Result<DishVO> getDishById(@PathVariable Long id){
    log.info("查询菜品：{}",id);
    DishVO dishVO=dishService.getDishByIdWithFlavor(id);
    return Result.success(dishVO);
}
```

##### service

```java
/**
     * 根据id查对应菜品以及口味
     * @param id
     * @return
     */
DishVO getDishByIdWithFlavor(Long id);
```

```java
/**
     * 根据id查对应菜品以及口味
     * @param id
     * @return
     */
@Override
public DishVO getDishByIdWithFlavor(Long id) {
    //根据id查询菜品信息
    Dish dish=dishMapper.getById(id);
    //根据菜品id查询口味相关数据
    List<DishFlavor> flavors=dishFlavorMapper.getFlavorByDishId(id);

    //构建 DishVO 对象
    DishVO dishVO=new DishVO();
    BeanUtils.copyProperties(dish,dishVO);
    dishVO.setFlavors(flavors);

    return dishVO;
}
```

##### mapper

```java
@Select("select * from sky_take_out.dish_flavor where dish_id=#{id}")
List<DishFlavor> getFlavorByDishId(Long id);
```

#### 修改菜品

`/admin/dish`

```json
//前端
{
  "categoryId": 0,
  "description": "string",
  "flavors": [
    {
      "dishId": 0,
      "id": 0,
      "name": "string",
      "value": "string"
    }
  ],
  "id": 0,
  "image": "string",
  "name": "string",
  "price": 0,
  "status": 0
}
//后端
{
  "code": 0,
  "data": "string",
  "msg": "string"
}
```

##### controller

```java
@PutMapping
@ApiOperation("更新菜品")
public Result update(@RequestBody DishDTO dishDTO){
    log.info("更新菜品：{}",dishDTO);
    dishService.updateDishWithFlavor(dishDTO);
    return Result.success();
}
```

##### service

```java
/**
     * 更新菜品以及对应的口味
     * @param dishDTO
     */
void updateDishWithFlavor(DishDTO dishDTO);
```

```java
/**
     * 更新菜品以及对应的口味
     *
     * @param dishDTO
     */
@Override
@Transactional
public void updateDishWithFlavor(DishDTO dishDTO) {
    //更新菜品表
    Dish dish = new Dish();
    BeanUtils.copyProperties(dishDTO, dish);
    dishMapper.update(dish);

    // 更新口味表 先删除数据库中现有口味 然后重新添加新口味
    dishFlavorMapper.deleteByDishId(dish.getId());
    //注意如果是新增的口味，没有 dish_id 需要手动加
    List<DishFlavor> flavors = dishDTO.getFlavors();
    if(flavors != null && !flavors.isEmpty()){
        //设置flavor中的dishId
        flavors.forEach(flavor -> flavor.setDishId(dish.getId()));
        //批量插入
        dishFlavorMapper.insertBatch(flavors);
    }
}
```

##### mapper

```java
/**
     * 修改菜品
     * @param dish
     */
@AutoFIll(value = OperationType.UPDATE)
void update(Dish dish);
```

```xml
<update id="update" parameterType="com.sky.entity.Dish">
    update dish
    <set>
        <if test="name != null">name=#{name},</if>
        <if test="categoryId != null">category_id=#{categoryId},</if>
        <if test="price != null">price=#{price},</if>
        <if test="image != null">image=#{image},</if>
        <if test="description != null">description=#{description},</if>
        <if test="status != null">status=#{status},</if>
        <if test="updateTime != null">update_time=#{updateTime},</if>
        <if test="updateUser != null">update_user=#{updateUser},</if>
    </set>
    where id = #{id}
</update>
```

### 根据分类id查询菜品

`/admin/dish/list`

```json
//前端 query形式分类categoryId

//后端
{
  "code": 0,
  "data": [
    {
      "categoryId": 0,
      "createTime": "2019-08-24T14:15:22Z",
      "createUser": 0,
      "description": "string",
      "id": 0,
      "image": "string",
      "name": "string",
      "price": 0,
      "status": 0,
      "updateTime": "2019-08-24T14:15:22Z",
      "updateUser": 0
    }
  ],
  "msg": "string"
}
```

#### controller

```java
@GetMapping("/list")
@ApiOperation("查询菜品列表")
public Result<List<Dish>> list(Long categoryId){
    log.info("查询菜品列表：{}",categoryId);
    List<Dish> dishes=dishService.getDishByCategoryId(categoryId);
    return Result.success(dishes);
}
```

#### service

```java
/**
     * 通过分类id获得菜品列表
     * @param categoryId
     * @return
     */
List<Dish> getDishByCategoryId(Long categoryId);
```

```java
/**
     * 通过分类id获得菜品列表
     *
     * @param categoryId
     * @return
     */
@Override
public List<Dish> getDishByCategoryId(Long categoryId) {
    List<Dish> dishes=dishMapper.getByCategoryId(categoryId);
    return dishes;
}
```

#### mapper

```java
@Select("select * from dish where category_id = #{categoryId}")
List<Dish> getByCategoryId(Long categoryId);
```

### 起售停售菜品

`/admin/dish/status/{status}`

```json
//前端 路径参数 status query 参数 菜品id
//后端
{
  "code": 0,
  "data": {},
  "msg": "string"
}
```

#### controller

```java

```

#### service

```java

```

```java

```

#### mapper

```java

```

```xml

```

## 套餐管理

### 新增套餐

`/admin/setmeal`

```json
//前端
{
    "categoryId": 0,
    "description": "string",
    "id": 0,
    "image": "string",
    "name": "string",
    "price": 0,
    "setmealDishes": [
        {
            "copies": 0,
            "dishId": 0,
            "id": 0,
            "name": "string",
            "price": 0,
            "setmealId": 0
        }
    ],
    "status": 0
}
//后端
{
    "code": 0,
    "data": {},
    "msg": "string"
}
```

#### controller

```java
@RestController
@RequestMapping("/admin/setmeal")
@Api(tags = "套餐相关接口")
@Slf4j
public class SetMealController {
    @Autowired
    SetMealService setMealService;

    @PostMapping
    @ApiOperation("新增套餐")
    public Result addSetMeal(@RequestBody SetmealDTO setmealDTO) {
        log.info("新增套餐:{}",setmealDTO);
        setMealService.addSetMealWithDish(setmealDTO);
        return Result.success();
    }

}
```

#### service

```java
public interface SetMealService {
    /**
     * 新增套餐 并且添加和菜品的关系
     * @param setmealDTO
     */
    void addSetMealWithDish(SetmealDTO setmealDTO);
}
```

```java
@Service
public class SetMealServiceImpl implements SetMealService {
    @Autowired
    SetMealMapper setMealMapper;
    @Autowired
    SetMealDishMapper setMealDishMapper;
    /**
     * 新增套餐 并且添加和菜品的关系
     *
     * @param setmealDTO
     */
    @Override
    public void addSetMealWithDish(SetmealDTO setmealDTO) {
        //向套餐表新增一个套餐
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);
        setMealMapper.insert(setmeal);

        Long id = setmeal.getId();//得到数据库回传的id

        //向套餐-菜品表插入数据
        List<SetmealDish> setmealDishes = setmealDTO.getSetmealDishes();
        if(setmealDishes!=null && !setmealDishes.isEmpty()) {
            //设置菜品对应套餐的id
            setmealDishes.forEach(setmealDish -> setmealDish.setSetmealId(id));
            //批量插入
            setMealDishMapper.insertBatch(setmealDishes);
        }
    }
}
```

#### mapper

SetMealMapper

```java
/**
     * 插入新套餐
     * @param setmeal
     */
@AutoFIll(value = OperationType.INSERT)
void insert(Setmeal setmeal);
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.sky.mapper.SetMealMapper">


    <insert id="insert" useGeneratedKeys="true" keyProperty="id">
        insert into setmeal(category_id, name, price, status,description, image, create_time, update_time, create_user, update_user)
        values (#{categoryId},#{name},#{price},#{status},#{description},#{image},#{createTime},#{updateTime},#{createUser},#{updateUser})
    </insert>
</mapper>
```

SetMealDishMapper

```java
/**
     * 插入套餐菜品数据
     * @param setmealDishes
     */
void insertBatch(List<SetmealDish> setmealDishes);
```

```xml
<insert id="insertBatch">
    insert into setmeal_dish (setmeal_id, dish_id,name,price,copies) values
    <foreach collection="setmealDishes" item="setmealDish" separator=",">
        (#{setmealDish.setmealId},#{setmealDish.dishId},#{setmealDish.name},#{setmealDish.price},#		{setmealDish.copies})
    </foreach>
</insert>
```

### 套餐分页查询

`/admin/setmeal/page`

```json
//前端 query类型
/**
     * 分类id
     */
categoryId?: string;
/**
     * 套餐名称
     */
name?: string;
/**
     * 页码
     */
page: string;
/**
     * 每页记录数
     */
pageSize: string;
/**
     * 套餐起售状态
     */
status?: string;

//后端
{
  "code": 0,
  "msg": null,
  "data": {
    "total": 0,
    "records": [
      {
        "id": 0,
        "categoryId": 0,
        "name": "string",
        "price": 0,
        "status": 0,
        "description": "string",
        "image": "string",
        "updateTime": "string",
        "categoryName": "string"
      }
    ]
  }
}
```

#### controller

```java
@GetMapping("/page")
@ApiOperation("分页查询套餐")
public Result<PageResult> page(SetmealPageQueryDTO setmealPageQueryDTO) {
    log.info("分页查询套餐:{}",setmealPageQueryDTO);
    PageResult pageResult=setMealService.pageQuery(setmealPageQueryDTO);
    return Result.success(pageResult);
}
```

#### service

```java
/**
     * 分页查询套餐
     * @param setmealPageQueryDTO
     * @return
     */
PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);
```

```java
/**
     * 分页查询套餐
     *
     * @param setmealPageQueryDTO
     * @return
     */
@Override
public PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO) {
    PageHelper.startPage(setmealPageQueryDTO.getPage(), setmealPageQueryDTO.getPageSize());
    Page<SetmealVO> page=setMealMapper.pageQuery(setmealPageQueryDTO);
    return new PageResult(page.getTotal(),page.getResult());
}
```

#### mapper

```java
/**
     * 分页查询套餐
     * @param setmealPageQueryDTO
     * @return
     */
Page<SetmealVO> pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);
```

```xml
<select id="pageQuery" resultType="com.sky.vo.SetmealVO">
    select setmeal.*,c.name as categoryName from setmeal left join category c on setmeal.category_id = c.id
    <where>
        <if test="categoryId != null"> and category_id=#{categoryId}</if>
        <if test="name != null"> and setmeal.name like concat("%",#{name},"%")</if>
        <if test="status != null">and setmeal.status=#{status}</if>
    </where>
</select>
```

### 根据id查询套餐

`/admin/setmeal/{id}`

```json
//前端 套餐id 路径参数
//后端
{
  "code": 0,
  "data": {
    "categoryId": 0,
    "categoryName": "string",
    "description": "string",
    "id": 0,
    "image": "string",
    "name": "string",
    "price": 0,
    "setmealDishes": [
      {
        "copies": 0,
        "dishId": 0,
        "id": 0,
        "name": "string",
        "price": 0,
        "setmealId": 0
      }
    ],
    "status": 0,
    "updateTime": "2019-08-24T14:15:22Z"
  },
  "msg": "string"
}
```

#### controller

```java
@GetMapping("/{id}")
@ApiOperation("根据id查询套餐")
public Result<SetmealVO> getById(@PathVariable Long id) {
    log.info("根据id查询套餐:{}",id);
    SetmealVO setmealVO=setMealService.getSetMealAndDishById(id);
    return Result.success(setmealVO);
}
```

#### service

```java
/**
     * 根据id查询套餐以及套餐对应菜品
     * @param id
     * @return
     */
SetmealVO getSetMealAndDishById(Long id);
```

```java
/**
     * 根据id查询套餐以及套餐对应菜品
     *
     * @param id
     * @return
     */
@Override
public SetmealVO getSetMealAndDishById(Long id) {
    //根据id查询套餐
    Setmeal setmeal=setMealMapper.getById(id);

    //根据套餐id查询套餐对应的菜品
    List<SetmealDish> setmealDishes=setMealDishMapper.getDishBySetMealId(id);

    //构建VO返回
    SetmealVO setmealVO=new SetmealVO();
    BeanUtils.copyProperties(setmeal,setmealVO);
    setmealVO.setSetmealDishes(setmealDishes);
    return setmealVO;
}
```

#### mapper

SetMealMapper

```java
/**
     * 根据id查询套餐
     * @param id
     * @return
     */
@Select("select * from setmeal where id=#{id}")
Setmeal getById(Long id);
```

SetMealDishMapper

```java
/**
     * 根据套餐id 查对应菜品
     * @param setMealId
     * @return
     */
List<SetmealDish> getDishBySetMealId(Long setMealId);
```

```xml
<select id="getDishBySetMealId" resultType="com.sky.entity.SetmealDish">
    select * from setmeal_dish where setmeal_id=#{setMealId}
</select>
```

### 批量删除套餐

`/admin/setmeal`

```json
//前端 query ids  例如?ids=1,2,3 使用注解requestparam

//后端
{
  "code": 0,
  "data": {},
  "msg": "string"
}
```

#### controller

```java
@DeleteMapping
@ApiOperation("删除套餐")
public Result delete(@RequestParam List<Long> ids) {
    log.info("删除菜品：{}",ids);
    //注意 ids 其实是字符串，逗号分隔
    //使用@RequestParam注解 Spring 会自动将逗号分隔的参数值解析
    setMealService.deleteBatch(ids);
    return Result.success();
}
```

#### service

```java
/**
     * 批量删除套餐
     * @param ids
     */
void deleteBatch(List<Long> ids);
```

```java
/**
     * 批量删除套餐
     *
     * @param ids
     */
@Override
public void deleteBatch(List<Long> ids) {
    //判断是否删除套餐 --status为1时不可以删除
    ids.forEach(id->{
        Setmeal setmeal = setMealMapper.getById(id);
        if(setmeal.getStatus().equals(StatusConstant.ENABLE)){
            throw new DeletionNotAllowedException(MessageConstant.SETMEAL_ON_SALE);
        }
    });
    //删除套餐
    setMealMapper.deleteBatch(ids);
    //删除套餐菜品表中数据
    setMealDishMapper.deleteBatch(ids);

}
```

#### mapper

setMealMapper

```java
@Select("select * from setmeal where id=#{id}")
Setmeal getById(Long id);

/**
     * 根据id集合批量删除套餐
     * @param ids
     */
void deleteBatch(List<Long> ids);
```

```xml
<delete id="deleteBatch">
    delete from setmeal where id in
    <foreach collection="ids" item="id" open="(" separator="," close=")">
        #{id}
    </foreach>
</delete>
```

SetMealDishMapper

```java
/**
     * 根据套餐id集合批量删除套餐菜品表数据
     * @param ids
     */
void deleteBatch(List<Long> ids);
```

```xml
<delete id="deleteBatch">
    delete from setmeal_dish where setmeal_id in
    <foreach collection="ids" item="id" open="(" separator="," close=")">
        #{id}
    </foreach>
</delete>
```

### 修改套餐

`/admin/setmeal`

```json
//前端 
{
  "categoryId": 0,
  "description": "string",
  "id": 0,
  "image": "string",
  "name": "string",
  "price": 0,
  "setmealDishes": [
    {
      "copies": 0,
      "dishId": 0,
      "id": 0,
      "name": "string",
      "price": 0,
      "setmealId": 0
    }
  ],
  "status": 0
}

//后端
{
  "code": 0,
  "data": {},
  "msg": "string"
}
```

#### controller

```java
@PutMapping
@ApiOperation("修改套餐")
public Result update(@RequestBody SetmealDTO setmealDTO) {
    log.info("修改套餐：{}",setmealDTO);
    setMealService.update(setmealDTO);
    return Result.success();
}
```

#### service

```java
/**
     * 修改套餐
     * @param setmealDTO
     */
void update(SetmealDTO setmealDTO);
```

```java
/**
     * 修改套餐
     *
     * @param setmealDTO
     */
@Override
public void update(SetmealDTO setmealDTO) {
    //修改套餐表
    Setmeal setmeal = new Setmeal();
    BeanUtils.copyProperties(setmealDTO, setmeal);
    setMealMapper.update(setmeal);

    //删除现有套餐包含的菜品
    List<Long> list = Collections.synchronizedList(new ArrayList<>());
    list.add(setmeal.getId());
    setMealDishMapper.deleteBatch(list);
    //套餐菜品表新增数据，注意新增无套餐id，需要手动添加
    List<SetmealDish> setmealDishes = setmealDTO.getSetmealDishes();
    if(setmealDishes!=null && !setmealDishes.isEmpty()) {
        setmealDishes.forEach(setmealDish -> setmealDish.setSetmealId(setmeal.getId()));
        setMealDishMapper.insertBatch(setmealDishes);
    }
}
```

#### mapper

setMealMapper

```java
/**
     * 修改套餐
     * @param setmeal
     */
@AutoFIll(value = OperationType.UPDATE)
void update(Setmeal setmeal);
```

```xml
<update id="update">
    update setmeal
    <set>
        <if test="categoryId != null">category_id=#{categoryId},</if>
        <if test="description != null">description=#{description},</if>
        <if test="image != null">image=#{image},</if>
        <if test="name != null">name=#{name},</if>
        <if test="price != null">price=#{price},</if>
        <if test="status != null">status=#{status},</if>
        <if test="updateTime != null">update_time=#{updateTime},</if>
        <if test="updateUser != null">update_user=#{updateUser},</if>
    </set>
    where id=#{id}
</update>
```

setMealDishMapper

```java
/**
     * 根据套餐id集合批量删除套餐菜品表数据
     * @param ids
     */
void deleteBatch(List<Long> ids);
```

```xml
<delete id="deleteBatch">
    delete from setmeal_dish where setmeal_id in
    <foreach collection="ids" item="id" open="(" separator="," close=")">
        #{id}
    </foreach>
</delete>
```

### 起售停售套餐

`/admin/setmeal/status/{status}`

```json
//前端 路径参数 status query 参数 套餐id
//后端
{
  "code": 0,
  "data": {},
  "msg": "string"
}
```

#### controller

```java
@PostMapping("/status/{status}")
@ApiOperation("修改套餐状态")
public Result setStatus(@PathVariable Integer status, @RequestParam Long id) {
    log.info("修改套餐状态：{},{}",id,status);
    setMealService.setStatus(id,status);
    return Result.success();
}
```

#### service

```java
/**
     * 设置套餐状态
     * @param id
     * @param status
     */
void setStatus(Long id, Integer status);
```

```java
/**
     * 设置套餐状态
     *
     * @param id
     * @param status
     */
@Override
public void setStatus(Long id, Integer status) {
    setMealMapper.setStatus(id, status);
}
```

#### mapper

```java
/**
     * 设置套餐状态
     * @param id
     * @param status
     */
@Update("update setmeal set status = #{status} where id = #{id} ")
void setStatus(Long id, Integer status);
```

## 营业状态修改

当营业状态改为打烊，小程序端无法点餐

* 查询营业状态
  * 商家查询营业状态  管理端  `/admin/shop/status ` get
  * 小程序查询营业状态 用户端 /user `/user/shop/status` get
* 修改营业状态 `/admin/shop/status` put

**因为只有一个字段，放mysql中建表太过于浪费，故放在 redis 中**

**约定：1表示营业 0表示打烊**

```json
//后端
{
  "code": 0,
  "data": 0,//1表示营业 0表示打烊
  "msg": "string"
}
```

### controller

adminShopController

```java
@RestController("adminShopController")
@RequestMapping("/admin/shop")
@Api(tags = "店铺管理")
@Slf4j
public class ShopController {
    @Autowired
    RedisTemplate redisTemplate;

    @GetMapping("/status")
    @ApiOperation("获取店铺状态")
    public Result<Integer> getShopStatus() {
        log.info("获取店铺状态");
        Integer shopStatus = (Integer) redisTemplate.opsForValue().get("shopStatus");
        return Result.success(shopStatus);
    }


    @PutMapping("/{status}")
    @ApiOperation("修改店铺状态")
    public Result setStatus(@PathVariable Integer status) {
        log.info("设置营业状态为：{}",status == 1 ? "营业中" : "打烊中");
        redisTemplate.opsForValue().set("shopStatus",status);
        return Result.success();
    }
}
```

userShopController

```java
@RestController("userShopController")
@RequestMapping("/user/shop")
@Api(tags = "用户端店铺相关接口")
@Slf4j
//@Qualifier("userShopController") 或者用该注解指定名字，一样的效果
public class ShopController {
    @Autowired
    RedisTemplate redisTemplate;

    @GetMapping("/status")
    @ApiOperation("获取店铺状态")
    public Result<Integer> getShopStatus() {
        log.info("获取店铺状态");
        Integer shopStatus = (Integer) redisTemplate.opsForValue().get("shopStatus");
        return Result.success(shopStatus);
    }
}
```

修改swagger文档使之正确显示相关接口

WebMvcConfiguration

```java
    /**
     * 通过knife4j生成接口文档 管理端
     * @return
     */
    @Bean
    public Docket docket() {
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title("苍穹外卖项目接口文档")
                .version("2.0")
                .description("苍穹外卖项目接口文档")
                .build();
        Docket docket = new Docket(DocumentationType.SWAGGER_2)
+               .groupName("管理端")
                .apiInfo(apiInfo)
                .select()
+                .apis(RequestHandlerSelectors.basePackage("com.sky.controller.admin"))
                .paths(PathSelectors.any())
                .build();
        return docket;
    }
    /**
     * 通过knife4j生成接口文档 用户端
     * @return
     */
    @Bean
    public Docket docket2() {
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title("苍穹外卖项目接口文档")
                .version("2.0")
                .description("苍穹外卖项目接口文档")
                .build();
        Docket docket = new Docket(DocumentationType.SWAGGER_2)
+                .groupName("用户端")
                .apiInfo(apiInfo)
                .select()
+                .apis(RequestHandlerSelectors.basePackage("com.sky.controller.user"))
                .paths(PathSelectors.any())
                .build();
        return docket;
    }
```

## 微信登录

![image-20240410210500312](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240410210500312.png)

1. 调用 [wx.login()](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html) 获取 **临时登录凭证code** ，并回传到开发者服务器。
2. 调用 [auth.code2Session](https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html) 接口，换取 **用户唯一标识 OpenID** 、 用户在微信开放平台账号下的**唯一标识UnionID**（若当前小程序已绑定到微信开放平台账号） 和 **会话密钥 session_key**。

```json
GET https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code 

//请求微信登录接口后的返回数据
{
    "openid":"xxxxxx", // 唯一标识用户
    "session_key":"xxxxx",
    "unionid":"xxxxx",
    "errcode":0,
    "errmsg":"xxxxx"
}
```

业务规则：

* 基于微信登录实现小程序的登录功能

* 如果是新用户需要自动完成注册

`/user/user/login`

```json
//前端
{
  "code": "string" //微信授权码
}
//后端
{
  "code": 0,
  "data": {
    "id": 0,
    "openid": "string", //唯一id
    "token": "string" // jwt
  },
  "msg": "string"
}
```

配置文件新增用户端jwt密钥以及微信相关

```yml
sky:
  jwt:
    .......
    # 设置jwt签名用户端加密时使用的秘钥
    user-secret-key: itheima
    # 设置jwt用户端过期时间
    user-ttl: 72000000
    # 设置用户端传递过来的令牌名称
    user-token-name: authentication
  alioss:
    ......
  wechat:
    appid: ${sky.wechat.appid}
    secret: ${sky.wechat.appsecret}
```

#### controller

```java

```

#### service

```java

```

```java

```

#### mapper

```java

```

```xml

```

## 小程序端

### 查询分类

`get /user/category/list`

```json
//前端 query 分类类型(可选)

//后端 即整个分类表字段
{
  "code": 0,
  "data": [
    {
      "createTime": "2019-08-24T14:15:22Z",
      "createUser": 0,
      "id": 0,
      "name": "string",
      "sort": 0,
      "status": 0,
      "type": 0,
      "updateTime": "2019-08-24T14:15:22Z",
      "updateUser": 0
    }
  ],
  "msg": "string"
}
```

#### controller

```java
@RestController("userCategoryController")
@RequestMapping("/user/category")
@Api(tags = "用户端分类相关接口")
@Slf4j
public class CategoryController {
    @Autowired
    CategoryService categoryService;

    @GetMapping("/list")
    @ApiOperation("分类列表")
    public Result<List<Category>> list(Integer type) {
        log.info("分类类型：{}", type);
        List<Category> categoryList = categoryService.getCategoryByType(type);
        return Result.success(categoryList);
    }
}
```

### 根据分类id查询菜品及其口味

`get /user/dish/list`

```java
//前端 query categoryId

//后端
{
  "code": 0,
  "data": [
    {
      "categoryId": 0,
      "categoryName": "string",
      "description": "string",
      "flavors": [
        {
          "dishId": 0,
          "id": 0,
          "name": "string",
          "value": "string"
        }
      ],
      "id": 0,
      "image": "string",
      "name": "string",
      "price": 0,
      "status": 0,
      "updateTime": "2019-08-24T14:15:22Z"
    }
  ],
  "msg": "string"
}
```

#### controller

```java
@RestController("userDishController")
@RequestMapping("/user/dish")
@Api(tags = "用户端菜品相关接口")
@Slf4j
public class DishController {
    @Autowired
    DishService dishService;

    @GetMapping("/list")
    @ApiOperation("根据分类id获取菜品及其口味")
    public Result<List<DishVO>> list(Long categoryId) {
        log.info("分类id：{}", categoryId);
        //注意需查询起售中的菜品
        List<DishVO> list = dishService.listWithFlavor(categoryId);
        return Result.success(list);
    }
}
```

#### service

```java
/**
     * 根据分类id查询菜品，注意菜品需为起售中
     * @param categoryId
     * @return
     */
List<DishVO> listWithFlavor(Long categoryId);
```

```java
/**
     * 根据分类id查询菜品，注意菜品需为起售中
     *
     * @param categoryId
     * @return
     */
@Override
public List<DishVO> listWithFlavor(Long categoryId) {
    //查询起售中的菜品
    List<Dish> dishList = dishMapper.getByCategoryId(categoryId);
    List<DishVO> dishVOList = new ArrayList<>();
    dishList.forEach(dish->{
        //若status不为1，说明该菜品不在起售中，不添加进DishVO返回列表
        if(dish.getStatus().equals(StatusConstant.ENABLE)){
            DishVO dishVO = new DishVO();
            BeanUtils.copyProperties(dish, dishVO);
            //查询菜品对应口味表
            List<DishFlavor> flavorList = dishFlavorMapper.getFlavorByDishId(dish.getId());
            dishVO.setFlavors(flavorList);
            dishVOList.add(dishVO);
        }
    });
    return dishVOList;
}
```

### 根据分类id查询套餐

`/user/setmeal/list`

```json
//前端 query categoryId

//后端 setmeal表
{
  "code": 0,
  "data": [
    {
      "categoryId": 0,
      "createTime": "2019-08-24T14:15:22Z",
      "createUser": 0,
      "description": "string",
      "id": 0,
      "image": "string",
      "name": "string",
      "price": 0,
      "status": 0,
      "updateTime": "2019-08-24T14:15:22Z",
      "updateUser": 0
    }
  ],
  "msg": "string"
}
```

#### controller

```java
@RestController("userSetMealController")
@RequestMapping("/user/setmeal")
@Api(tags = "C端-套餐浏览接口")
@Slf4j
public class SetMealController {
    @Autowired
    SetMealService setMealService;

    @GetMapping("/list")
    @ApiOperation("根据分类id查询套餐")
    public Result<List<Setmeal>> list(Long categoryId){
        log.info("根据分类id查询套餐：{}",categoryId);
        Setmeal setmeal = new Setmeal();
        setmeal.setCategoryId(categoryId);
        List<Setmeal> setmealList = setMealService.list(setmeal);
        return Result.success(setmealList);
    }

}
```

#### service

```java
/**
     * 根据分类id查询相应套餐 注意需为起售中
     * @param setmeal
     * @return
     */
List<Setmeal> list(Setmeal setmeal);
```

```java
/**
     * 根据分类id查询相应套餐 注意需为起售中
     *
     * @param setmeal
     * @return
     */
@Override
public List<Setmeal> list(Setmeal setmeal) {
    //根据分类id查询相应套餐 注意需为起售中
    //此处为了查询复用可以使用传入对象，动态查询
    List<Setmeal> list = setMealMapper.list(setmeal);
    return list;
}
```

#### mapper

```java
/**
     * 根据分类id查询套餐，需为起售中
     * @param setmeal
     * @return
     */
List<Setmeal> list(Setmeal setmeal);
```

```xml
<select id="list" resultType="com.sky.entity.Setmeal">
    select * from setmeal
    <where>
        <if test="categoryId != null">
            and category_id=#{categoryId}
        </if>
        <if test="name != null">
            and name like concat('%',#{name},'%')
        </if>
        <if test="status != null">
            and status=#{status}
        </if>
    </where>
</select>
```

### 根据套餐id查询包含的菜品

`get /user/setmeal/dish/{id}`

```json
//前端 path参数 套餐id

//后端 dish表查菜品名 图片 描述 
{
  "code": 0,
  "data": [
    {
      "copies": 0, //份数
      "description": "string", // 描述
      "image": "string",// 图片地址
      "name": "string" //菜品名
    }
  ],
  "msg": "string"
}
```

#### controller

```java
@GetMapping("/dish/{id}")
@ApiOperation("根据套餐id查询包含的菜品")
public Result<List<DishItemVO>> listDish(@PathVariable Long id){
    log.info("根据套餐id查询包含的菜品：{}",id);
    List<DishItemVO> list = setMealService.getDishItemBySetMealId(id);
    return Result.success(list);
}
```

#### service

```java
/**
     * 根据套餐id获取DishItem
     * @param id
     * @return
     */
List<DishItemVO> getDishItemBySetMealId(Long id);
```

```java
/**
     * 根据套餐id获取DishItem
     *
     * @param setMealId
     * @return
     */
@Override
public List<DishItemVO> getDishItemBySetMealId(Long setMealId) {
    return setMealMapper.getDishItemBySetMealId(setMealId);
}
```

#### mapper

```java
@Select("select setmeal_dish.copies,setmeal_dish.name,dish.image,dish.description " +
        "from setmeal_dish left join dish on setmeal_dish.dish_id=dish.id " +
        "where setmeal_dish.setmeal_id=#{setmealId}")
List<DishItemVO> getDishItemBySetMealId(Long setmealId);
```

注意这里使用左外连接而不是使用两个条件

实际上是设计的问题，直接两个条件判断也可以，因为套餐中的菜品必定在菜品表中，不会出现为null的情况

### 缓存菜品

现在所有的菜品以及分类实际上都是查询数据库生成，如果**有很多人访问，势必会造成数据库压力过大，可能会导致服务响应慢等问题**

我们可以将商品数据放在redis中缓存从而提高响应速度

![image-20240411200356401](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240411200356401.png)

![image-20240411201347488](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240411201347488.png)

#### controller

userDishController

```java
@RestController("userDishController")
@RequestMapping("/user/dish")
@Api(tags = "用户端菜品相关接口")
@Slf4j
public class DishController {
    @Autowired
    DishService dishService;
    @Autowired
    RedisTemplate redisTemplate;

    @GetMapping("/list")
    @ApiOperation("根据分类id获取菜品及其口味")
    public Result<List<DishVO>> list(Long categoryId) {
        log.info("分类id：{}", categoryId);
        //构造redis缓存key 规则 dish_ + categoryId
        String key="dish_"+categoryId;
        //根据key查询redis
        List<DishVO> list = (List<DishVO>) redisTemplate.opsForValue().get(key);
        //若有缓存数据，直接返回
        if(list!=null && !list.isEmpty()){
            return Result.success(list);
        }
        //若无缓存数据，正常查询
        //注意需查询起售中的菜品
        list = dishService.listWithFlavor(categoryId);

        //将数据缓存至redis中
        redisTemplate.opsForValue().set(key,list);

        return Result.success(list);
    }
}
```

**当进行数据库dml操作时会影响数据库中数据，此时应该及时清理缓冲**

修改管理端接口DishController的相关方法，加入清理缓存的逻辑，需要改造的方法：

* 新增菜品
* 修改菜品
* 批量删除菜品
* 起售、停售菜品

```java
@RestController
@RequestMapping("/admin/dish")
@Api(tags = "菜品管理接口")
@Slf4j
public class DishController {
    @Autowired
    DishService dishService;
    @Autowired
    RedisTemplate redisTemplate;

    @PostMapping
    @ApiOperation("添加菜品")
    public Result addDish(@RequestBody DishDTO dishDTO){
        log.info("添加菜品:{}",dishDTO);
        //清理redis缓存
        cleanCache("dish_"+dishDTO.getCategoryId());

        dishService.addDishWithFlavor(dishDTO);
        return Result.success();
    }

    .......

    @DeleteMapping
    @ApiOperation("删除菜品")
    public Result delete(@RequestParam List<Long> ids){
        log.info("删除菜品：{}",ids);
        //注意 ids 其实是字符串，逗号分隔
        //使用@RequestParam注解 Spring 会自动将逗号分隔的参数值解析
        dishService.deleteBatch(ids);

        //清理redis缓存
        cleanCache("dish_*");

        return Result.success();
    }

    .......

    @PutMapping
    @ApiOperation("更新菜品")
    public Result update(@RequestBody DishDTO dishDTO){
        log.info("更新菜品：{}",dishDTO);
        dishService.updateDishWithFlavor(dishDTO);
        //清理redis缓存
        cleanCache("dish_*");
        return Result.success();
    }

    @PostMapping("/status/{status}")
    @ApiOperation("修改菜品状态")
    public Result setStatus(@PathVariable Integer status,@RequestParam Long id){
        log.info("修改菜品状态：{} {}",id,status);
        dishService.setStatus(id,status);
        //清理redis缓存
        cleanCache("dish_*");

        return Result.success();
    }

    /**
     * 清理缓存
     * @param pattern
     */
    private void cleanCache(String pattern){
        Set keys = redisTemplate.keys(pattern);
        redisTemplate.delete(keys);
    }

}
```

### 缓存套餐

具体的实现思路如下：

* 导入Spring Cache和Redis相关maven坐标
* 在启动类上加入@EnableCaching注解，开启缓存注解功能
* 在用户端接口SetmealController的 `list` 方法上加入@Cacheable注解
* 在管理端接口SetmealController的 `save`、`delete`、`update`、`startOrStop`等方法上加入CacheEvict注解

userSetMealController

```java
......
public class SetMealController {
    @Autowired
    SetMealService setMealService;

    @GetMapping("/list")
    @ApiOperation("根据分类id查询套餐")
    @Cacheable(cacheNames = "setmealCache",key = "#categoryId")
    public Result<List<Setmeal>> list(Long categoryId){
        ........
    }

......

}
```

adminSetMealController

```java
public class SetMealController {
    @Autowired
    SetMealService setMealService;

    @PostMapping
    @ApiOperation("新增套餐")
    @CacheEvict(value = "setmealCache",key="#setmealDTO.categoryId")
    public Result addSetMeal(@RequestBody SetmealDTO setmealDTO) {
        ....
    }

    .......

    @DeleteMapping
    @ApiOperation("删除套餐")
    @CacheEvict(value = "setmealCache",allEntries = true)
    public Result delete(@RequestParam List<Long> ids) {
        ......
    }

    @PutMapping
    @ApiOperation("修改套餐")
    @CacheEvict(value = "setmealCache",allEntries = true)
    public Result update(@RequestBody SetmealDTO setmealDTO) {
        ......
    }

    @PostMapping("/status/{status}")
    @ApiOperation("修改套餐状态")
    @CacheEvict(value = "setmealCache",allEntries = true)
    public Result setStatus(@PathVariable Integer status, @RequestParam Long id) {
        .....
    }
}
```

### 添加购物车

![image-20240413134650331](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240413134650331.png)

`post /user/shoppingCart/add`

```json
//前端
{
  "dishFlavor": "string",//口味
  "dishId": 0,//菜品id
  "setmealId": 0//套餐id
}
//后端
{
  "code": 0,
  "data": "string",
  "msg": "string"
}
```

若有多份相同商品，只需要执行修改操作，将数量+1

* 根据 userid 和 setmealid / dishid dishflavor 查询是否已经存在（不同口味也是新的菜品）

* 若不存在，新建插入，若存在，修改份数

#### controller

```java
@RestController
@RequestMapping("/user/shoppingCart")
@Api(tags = "C端-购物车相关端口")
@Slf4j
public class ShoppingCartController {
    @Autowired
    ShoppingCartService shoppingCartService;

    @PostMapping("/add")
    public Result addShoppingCart(@RequestBody ShoppingCartDTO shoppingCartDTO) {
        log.info("添加至购物车的商品：{}", shoppingCartDTO);
        shoppingCartService.add(shoppingCartDTO);
        return  Result.success();
    }
    
}
```

#### service

```java
public interface ShoppingCartService {
    void add(ShoppingCartDTO shoppingCartDTO);
}
```

```java
@Service
public class ShoppingCartServiceImpl implements ShoppingCartService {
    @Autowired
    ShoppingCartMapper shoppingCartMapper;
    @Autowired
    DishMapper dishMapper;
    @Autowired
    SetMealMapper setMealMapper;

    @Override
    public void add(ShoppingCartDTO shoppingCartDTO) {
        //添加之前考虑当前购物车表有无该条数据
        //通过 userid setmealid/dishid flavor判断
        ShoppingCart shoppingCart = new ShoppingCart();
        BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);
        shoppingCart.setUserId(BaseContext.getCurrentId());
        List<ShoppingCart> list = shoppingCartMapper.list(shoppingCart);

        if (list != null && !list.isEmpty()) {
            //若已存在，数量+1
            ShoppingCart cart = list.get(0);
            cart.setNumber(cart.getNumber() + 1);
            shoppingCartMapper.update(cart);
        }else{
            //若不存在，插入数据
            //判断是菜品还是套餐
            if(shoppingCart.getDishId() != null){
                //若为菜品
                Dish dish = dishMapper.getById(shoppingCart.getDishId());
                shoppingCart.setName(dish.getName());
                shoppingCart.setImage(dish.getImage());
                shoppingCart.setAmount(dish.getPrice());
            }else{
                //若为套餐
                Setmeal setmeal = setMealMapper.getById(shoppingCart.getSetmealId());
                shoppingCart.setName(setmeal.getName());
                shoppingCart.setImage(setmeal.getImage());
                shoppingCart.setAmount(setmeal.getPrice());
            }
            shoppingCart.setNumber(1);
            shoppingCart.setCreateTime(LocalDateTime.now());
            shoppingCartMapper.add(shoppingCart);
        }
    }
}
```

#### mapper

```java
@Mapper
public interface ShoppingCartMapper {
    List<ShoppingCart> list(ShoppingCart shoppingCart);

    @Update("update shopping_cart set number = #{number} where id=#{id}")
    void update(ShoppingCart cart);

    @Insert("insert into shopping_cart(name,image,user_id,setmeal_id,dish_id,dish_flavor,number,amount,create_time) " +
            "values(#{name},#{image},#{userId},#{setmealId},#{dishId},#{dishFlavor},#{number},#{amount},#{createTime})"
    )
    void add(ShoppingCart shoppingCart);
}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.sky.mapper.ShoppingCartMapper">


    <select id="list" resultType="com.sky.entity.ShoppingCart">
        select * from shopping_cart
        <where>
            <if test="userId != null">
                and user_id = #{userId}
            </if>
            <if test="dishId != null">
                and dish_id = #{dishId}
            </if>
            <if test="setmealId != null">
                and setmeal_id = #{setmealId}
            </if>
            <if test="dishFlavor != null">
                and dish_flavor = #{dishFlavor}
            </if>
        </where>
    </select>
</mapper>
```

****

### 查看购物车

`get /user/shoppingCart/list`

```json
//后端
{
  "code": 0,
  "data": [
    {
      "amount": 0,
      "createTime": "2019-08-24T14:15:22Z",
      "dishFlavor": "string", //口味
      "dishId": 0, //菜品id
      "id": 0,
      "image": "string",
      "name": "string",
      "number": 0,
      "setmealId": 0, //套餐id
      "userId": 0
    }
  ],
  "msg": "string"
}
```

#### controller

```java
@GetMapping("/list")
@ApiOperation("查看购物车")
public Result<List<ShoppingCart>> list() {
    log.info("查看购物车");
    List<ShoppingCart> list = shoppingCartService.list();
    return Result.success(list);
}
```

#### service

```java
/**
     * 查看当前用户的购物车
     * @return
     */
List<ShoppingCart> list();
```

```java
/**
     * 查看当前用户的购物车
     *
     * @return
     */
@Override
public List<ShoppingCart> list() {
    ShoppingCart shoppingCart = new ShoppingCart();
    shoppingCart.setUserId(BaseContext.getCurrentId());
    List<ShoppingCart> list = shoppingCartMapper.list(shoppingCart);
    return list;
}
```

****

### 清空购物车

`clean /user/shoppingCart/clean`

```json
//后端
{
    "code": 0,
    "data": "string",
    "msg": "string"
}
```

#### controller

```java
@DeleteMapping("/clean")
@ApiOperation("清空购物车")
public Result clean() {
    log.info("清空购物车");
    shoppingCartService.clean();
    return Result.success();
}
```

#### service

```java
/**
     * 清空购物车
     */
void clean();
```

```java
/**
     * 清空购物车
     */
@Override
public void clean() {
    shoppingCartMapper.clean(BaseContext.getCurrentId());
}
```

#### mapper

```java
@Delete("delete from shopping_cart where user_id=#{userId}")
void clean(Long currentId);
```

****

### 删除购物车中一个商品

`post /user/shoppingCart/sub`

```json
//前端
{
  "dishFlavor": "string",
  "dishId": 0,
  "setmealId": 0
}
//后端
{
  "code": 0,
  "data": "string",
  "msg": "string"
}
```

#### controller

```java
@PostMapping("/sub")
@ApiOperation("减少购物车商品")
public Result subShoppingCart(@RequestBody ShoppingCartDTO shoppingCartDTO) {
    log.info("减少购物车商品：{}", shoppingCartDTO);
    shoppingCartService.delete(shoppingCartDTO);
    return  Result.success();
}
```

#### service

```java
/**
     * 减少购物车中商品
     * @param shoppingCartDTO
     */
void delete(ShoppingCartDTO shoppingCartDTO);
```

```java
/**
     * 减少购物车中商品
     *
     * @param shoppingCartDTO
     */
@Override
public void delete(ShoppingCartDTO shoppingCartDTO) {
    ShoppingCart shoppingCart = new ShoppingCart();
    BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);
    shoppingCart.setUserId(BaseContext.getCurrentId());
    //先查询当前商品在购物车中的数量 若大于1，数量-1 否则删除
    List<ShoppingCart> list = shoppingCartMapper.list(shoppingCart);
    if(list != null && !list.isEmpty()){
        ShoppingCart cart = list.get(0);
        if(cart.getNumber() > 1){
            cart.setNumber(cart.getNumber() - 1);
            shoppingCartMapper.update(cart);
        }else{
            shoppingCartMapper.delete(shoppingCart);
        }
    }
}
```

#### mapper

```java
void delete(ShoppingCart shoppingCart);
```

```xml
<delete id="delete">
    delete from shopping_cart
    <where>
        <if test="userId != null">
            and user_id = #{userId}
        </if>
        <if test="dishId != null">
            and dish_id = #{dishId}
        </if>
        <if test="setmealId != null">
            and setmeal_id = #{setmealId}
        </if>
        <if test="dishFlavor != null">
            and dish_flavor = #{dishFlavor}
        </if>
    </where>
</delete>
```

## C端-地址簿接口

![image-20240413155826775](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240413155826775.png)

### 查询所有地址列表

`get /user/addressBook/list`

```json
//前端

//后端
{
  "code": 0,
  "data": {
    "id": 0,
    "userId": 0,
    "consignee": "string",
    "phone": "string",
    "sex": "string",
    "provinceCode": "string",
    "provinceName": "string",
    "cityCode": "string",
    "cityName": "string",
    "districtCode": "string",
    "districtName": "string",
    "detail": "string",
    "label": "string",
    "isDefault": 0
  },
  "msg": "string"
}
```

#### controller

```java
@GetMapping("/list")
@ApiOperation("获取地址列表")
public Result<List<AddressBook>> getAddressList() {
    log.info("获取地址列表");
    List<AddressBook> addressBookList = addressBookService.getAddressList();
    return Result.success(addressBookList);
}
```

#### service

```java
List<AddressBook> getAddressList();
```

```java
@Override
public List<AddressBook> getAddressList() {
    return addressBookMapper.list(BaseContext.getCurrentId());
}
```

#### mapper

```java
@Select("select * from address_book where user_id = #{userId}")
List<AddressBook> list(Long addressBook);
```

****

### 根据id查询地址

`get /user/addressBook/{id}`

```json
//前端 路径参数 地址id

//后端
{
  "code": 0,
  "data": {
    "id": 0,
    "phone": "string",
    "consignee": "string",
    "userId": 0,
    "cityCode": "string",
    "provinceName": "string",
    "provinceCode": "string",
    "sex": "string",
    "districtName": "string",
    "districtCode": "string",
    "cityName": "string",
    "isDefault": 0,
    "label": "string",
    "detail": "string"
  },
  "msg": "string"
}
```

#### controller

```java
@GetMapping("/{id}")
@ApiOperation("根据地址id获取地址")
public Result<AddressBook> getAddress(@PathVariable Long id) {
    log.info("根据地址id获取地址:{}", id);
    AddressBook addressBook = addressBookService.getAddress(id);
    return Result.success(addressBook);
}
```

#### service

```java
/**
     * 根据地址id获取地址
     * @param id
     * @return
     */
AddressBook getAddress(Long id);
```

```java
/**
     * 根据地址id获取地址
     * @param id
     * @return
     */
@Override
public AddressBook getAddress(Long id) {
    AddressBook addressBook = AddressBook
        .builder()
        .userId(BaseContext.getCurrentId())
        .id(id)
        .build();
    return addressBookMapper.getAddress(addressBook);
}
```

****

### 新增地址

`post /user/addressBook`

```json
//前端 json
{
  "cityCode": "string",
  "cityName": "string",
  "consignee": "string",
  "detail": "string",
  "districtCode": "string",
  "districtName": "string",
  "id": 0,
  "isDefault": 0,
  "label": "string",
  "phone": "string",
  "provinceCode": "string",
  "provinceName": "string",
  "sex": "string",
  "userId": 0
}
//后端
{
  "code": 0,
  "data": {},
  "msg": "string"
}
```

#### controller

```java
@RestController
@RequestMapping("/addressBook")
@Api(tags = "C端-地址簿相关接口")
@Slf4j
public class AddressBookController {
    @Autowired
    AddressBookService addressBookService;

    @PostMapping
    @ApiOperation("添加新地址")
    public Result addAddress(@RequestBody AddressBook addressBook) {
        log.info("添加新地址:{}", addressBook);
        addressBookService.addAddress(addressBook);
        return Result.success();
    }
}
```

#### service

```java
public interface AddressBookService {
    void addAddress(AddressBook addressBook);
}
```

```java
@Service
public class AddressBookServiceImpl implements AddressBookService {
    @Autowired
    AddressBookMapper addressBookMapper;
    @Override
    public void addAddress(AddressBook addressBook) {
        addressBook.setUserId(BaseContext.getCurrentId());
        addressBook.setIsDefault(0);//注意需设置，数据库此处不为null
        addressBookMapper.insert(addressBook);
    }
}
```

#### mapper

```java
@Mapper
public interface AddressBookMapper {
    void insert(AddressBook addressBook);
}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.sky.mapper.AddressBookMapper">


    <insert id="insert">
        insert into
            address_book(user_id,consignee,sex,phone,province_code,province_name,city_code,city_name,district_code,district_name,detail,label,is_default)
        values
            (#{userId},#{consignee},#{sex},#{phone},#{provinceCode},#{provinceName},#{cityCode},#{cityName},#{districtCode},#{districtName},#{detail},#{label},#{isDefault})
    </insert>
</mapper>
```

****

### 根据id修改地址

`put /user/addressBook`

```json
//前端
{
  "cityCode": "string",
  "cityName": "string",
  "consignee": "string",
  "detail": "string",
  "districtCode": "string",
  "districtName": "string",
  "id": 0,
  "isDefault": 0,
  "label": "string",
  "phone": "string",
  "provinceCode": "string",
  "provinceName": "string",
  "sex": "string",
  "userId": 0
}
//后端
{
  "code": 0,
  "data": {},
  "msg": "string"
}
```

#### controller

```java
@PutMapping
@ApiOperation("更新地址")
public Result updateAddress(@RequestBody AddressBook addressBook) {
    log.info("更新地址:{}", addressBook);
    addressBookService.updateAddress(addressBook);
    return Result.success();
}
```

#### service

```java
/**
     * 更新地址
     * @param addressBook
     */
void updateAddress(AddressBook addressBook);
```

```java
/**
     * 更新地址
     *
     * @param addressBook
     */
@Override
public void updateAddress(AddressBook addressBook) {
    addressBookMapper.update(addressBook);
}
```

#### mapper

```java
void update(AddressBook addressBook);
```

```xml
<update id="update">
    update address_book
    <set>
        <if test="userId != null">user_id = #{userId},</if>
        <if test="consignee != null">consignee = #{consignee},</if>
        <if test="sex != null">sex = #{sex},</if>
        <if test="phone != null">phone = #{phone},</if>
        <if test="provinceCode != null">province_code = #{provinceCode},</if>
        <if test="provinceName != null">province_name = #{provinceName},</if>
        <if test="cityCode != null">city_code = #{cityCode},</if>
        <if test="cityName != null">city_name = #{cityName},</if>
        <if test="districtCode != null">district_code = #{districtCode},</if>
        <if test="detail != null">detail = #{detail},</if>
        <if test="label != null">label = #{label},</if>
        <if test="isDefault != null">is_default = #{isDefault},</if>
    </set>
    where id=#{id}
</update>
```

#### 功能完善

****

### 根据id删除地址

`delete /user/addressBook`

```json
//前端 query参数 地址id

//后端
{
  "code": 0,
  "data": {},
  "msg": "string"
}
```

#### controller

```java
@DeleteMapping
@ApiOperation("根据地址id删除地址")
public Result deleteAddress(@RequestParam Long id) {
    log.info("删除地址:{}", id);
    addressBookService.deleteAddress(id);
    return Result.success();
}
```

#### service

```java
/**
     * 根据地址id删除地址
     * @param id
     */
void deleteAddress(Long id);
```

```java
/**
     * 根据地址id删除地址
     *
     * @param id
     */
@Override
public void deleteAddress(Long id) {
    addressBookMapper.delete(id);
}
```

#### mapper

```java
@Delete("delete from address_book where id=#{id}")
void delete(Long id);
```

****

### 设置默认地址

`put /user/addressBook/default`

```json
//前端
{
  "id": 0
}
//后端
{
  "code": 0,
  "data": {},
  "msg": "string"
}
```

#### controller

```java

```

#### service

```java

```

```java

```

#### mapper

```java

```

```xml

```

#### 功能完善

****

### 查询默认地址

`get /user/addressBook/default `

```json
//前端

//后端
{
    "code": 0,
    "data": {
        "cityCode": "string",
        "cityName": "string",
        "consignee": "string",
        "detail": "string",
        "districtCode": "string",
        "districtName": "string",
        "id": 0,
        "isDefault": 0,
        "label": "string",
        "phone": "string",
        "provinceCode": "string",
        "provinceName": "string",
        "sex": "string",
        "userId": 0
    },
    "msg": "string"
}
```

#### controller

```java
@GetMapping("/default")
@ApiOperation("获取默认地址")
public Result<AddressBook> getDefaultAddress() {
    log.info("获取默认地址");
    AddressBook addressBook = addressBookService.getDefaultAddress();
    return Result.success(addressBook);
}
```

#### service

```java
/**
     * 获取默认地址
     * @return
     */
AddressBook getDefaultAddress();
```

```java
@Override
public AddressBook getDefaultAddress() {
    AddressBook addressBook = AddressBook
        .builder()
        .userId(BaseContext.getCurrentId())
        .isDefault(1)
        .build();
    return addressBookMapper.getAddress(addressBook);
}
```

#### mapper

```java
AddressBook getAddress(AddressBook addressBook);
```

```xml
<select id="getAddress" resultType="com.sky.entity.AddressBook">
    select * from address_book
    <where>
        <if test="userId != null">
            and user_id = #{userId}
        </if>
        <if test="isDefault != null">
            and is_default = #{isDefault}
        </if>
        <if test="id != null">
            and id = #{id}
        </if>
    </where>
</select>
```

****

## C端-订单接口

![image-20240413191328892](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240413191328892.png)

![image-20240413191704707](https://raw.githubusercontent.com/balance-hy/typora/master/thinkbook/image-20240413191704707.png)

### 用户下单

``

```json
//前端

//后端
```

#### controller

```java
@RestController("userOrderController")
@RequestMapping("/user/order")
@Api(tags = "C端-订单相关接口")
@Slf4j
public class OrderController {

    @Autowired
    OrderService orderService;

    @PostMapping("/submit")
    @ApiOperation("用户下单")
    public Result<OrderSubmitVO> submit(@RequestBody OrdersSubmitDTO ordersSubmitDTO) {
        log.info("用户下单:{}", ordersSubmitDTO);
        OrderSubmitVO orderSubmitVO = orderService.submit(ordersSubmitDTO);
        return Result.success(orderSubmitVO);
    }
}
```

#### service

```java
public interface OrderService {
    /**
     * 用户下单
     * @param ordersSubmitDTO
     * @return
     */
    OrderSubmitVO submit(OrdersSubmitDTO ordersSubmitDTO);
}
```

```java
@Service
public class OrderServiceImpl implements OrderService {
    @Autowired
    OrderMapper orderMapper;
    @Autowired
    OrderDetailMapper orderDetailMapper;
    @Autowired
    AddressBookMapper addressBookMapper;
    @Autowired
    ShoppingCartMapper shoppingCartMapper;

    /**
     * 用户下单
     *
     * @param ordersSubmitDTO
     * @return
     */
    @Override
    @Transactional //多个插入，启用事务
    public OrderSubmitVO submit(OrdersSubmitDTO ordersSubmitDTO) {
        AddressBook addressBook = new AddressBook();
        addressBook.setId(ordersSubmitDTO.getAddressBookId());
        //判断地址和购物车是否为空
        AddressBook address = addressBookMapper.getAddress(addressBook);
        if(address == null){
            throw new AddressBookBusinessException(MessageConstant.ADDRESS_BOOK_IS_NULL);
        }
        ShoppingCart shoppingCart = new ShoppingCart();
        shoppingCart.setUserId(BaseContext.getCurrentId());
        List<ShoppingCart> shoppingCartList= shoppingCartMapper.list(shoppingCart);
        if(shoppingCartList==null|| shoppingCartList.isEmpty()){
            throw new AddressBookBusinessException(MessageConstant.SHOPPING_CART_IS_NULL);
        }
        //向订单表插入1条数据
        Orders orders = new Orders();
        BeanUtils.copyProperties(ordersSubmitDTO,orders);
        orders.setNumber(String.valueOf(System.currentTimeMillis())); //订单号
        orders.setOrderTime(LocalDateTime.now());//下单时间
        orders.setPayStatus(Orders.UN_PAID);//支付状态
        orders.setStatus(Orders.PENDING_PAYMENT);//订单状态
        orders.setPhone(address.getPhone());//电话
        orders.setConsignee(address.getConsignee());//收货人
        orders.setUserId(BaseContext.getCurrentId());//用户id

        orderMapper.insert(orders);
        //向订单明细表插入n条数据
        ArrayList<OrderDetail> orderDetailList = new ArrayList<>();
        shoppingCartList.forEach(cart->{
            OrderDetail orderDetail = new OrderDetail();
            BeanUtils.copyProperties(cart,orderDetail);
            orderDetail.setOrderId(orders.getId());//设置当前订单明细关联的订单id
            orderDetailList.add(orderDetail);
        });
        orderDetailMapper.insertBatch(orderDetailList);

        //清空用户的购物车
        shoppingCartMapper.clean(BaseContext.getCurrentId());
        //封装返回OrderSubmitVO
        OrderSubmitVO orderSubmitVO = OrderSubmitVO.builder()
                .id(orders.getId())
                .orderTime(orders.getOrderTime())
                .orderAmount(orders.getAmount())
                .orderNumber(orders.getNumber()).build();

        return orderSubmitVO;
    }
}
```

#### mapper

OrderMapper

```java
@Mapper
public interface OrderMapper {
    void insert(Orders orders);
}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.sky.mapper.OrderMapper">

    <insert id="insert" useGeneratedKeys="true" keyProperty="id">
        insert into sky_take_out.orders(number, status, user_id, address_book_id, order_time, checkout_time,
                                        pay_method, pay_status, amount, remark, phone, address,
                                        consignee, cancel_reason, rejection_reason,
                                        cancel_time, estimated_delivery_time, delivery_status,
                                        delivery_time, pack_amount, tableware_number, tableware_status)
        values(#{number}, #{status}, #{userId}, #{addressBookId}, #{orderTime}, #{checkoutTime},
               #{payMethod}, #{payStatus}, #{amount}, #{remark}, #{phone}, #{address},
               #{consignee}, #{cancelReason}, #{rejectionReason},
               #{cancelTime}, #{estimatedDeliveryTime}, #{deliveryStatus},
               #{deliveryTime}, #{packAmount}, #{tablewareNumber}, #{tablewareStatus})
    </insert>
</mapper>
```

OrderDetailMapper

```java
@Mapper
public interface OrderDetailMapper {
    void insertBatch(ArrayList<OrderDetail> orderDetailList);
}

```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.sky.mapper.OrderDetailMapper">


    <insert id="insertBatch">
        insert into order_detail(name, image, order_id, dish_id, setmeal_id, dish_flavor, number,amount)
        values 
            <foreach collection="orderDetailList" item="orderDetail" separator=",">
            (#{orderDetail.name},#{orderDetail.image},#{orderDetail.orderId},#{orderDetail.dishId},
             #{orderDetail.setmealId},#{orderDetail.dishFlavor},#{orderDetail.number},#{orderDetail.amount})
            </foreach>
    </insert>
</mapper>
```

#### 功能完善

```java
@Transactional //多个插入，启用事务
```

****





























## common

``

```json
//前端

//后端
```

#### controller

```java

```

#### service

```java
```

```java

```

#### mapper

```java
```

```xml

```

#### 功能完善

****

